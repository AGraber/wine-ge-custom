From 85896e8ad6c4052b5f049edfaeec0cc82ffa28c3 Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 13:41:51 +0000
Subject: [PATCH] winebus: Keep track of input device class in instance struct

This avoids having to keep comparing the subsystem as a string, and in
particular means we don't need a fully-working struct udev_device at
the point when we remove devices.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 54 ++++++++++++++++++++++++-------------
 1 file changed, 36 insertions(+), 18 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 280ffc9323f..db8744b96a1 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -105,6 +105,7 @@ struct vidpid {
 
 struct platform_private
 {
+    const platform_vtbl *vtbl;
     struct udev_device *udev_device;
     int device_fd;
 
@@ -1222,6 +1223,10 @@ static void try_add_device(struct udev_device *dev)
     WORD input = -1;
     int fd;
     static const CHAR *base_serial = "0000";
+    const platform_vtbl *vtbl = NULL;
+#ifdef HAS_PROPER_INPUT_HEADER
+    const platform_vtbl *other_vtbl = NULL;
+#endif
 
     if (!(devnode = udev_device_get_devnode(dev)))
         return;
@@ -1233,17 +1238,34 @@ static void try_add_device(struct udev_device *dev)
     }
 
     subsystem = udev_device_get_subsystem(dev);
+
+    if (strcmp(subsystem, "hidraw") == 0)
+    {
+        vtbl = &hidraw_vtbl;
+#ifdef HAS_PROPER_INPUT_HEADER
+        other_vtbl = &lnxev_vtbl;
+#endif
+    }
+#ifdef HAS_PROPER_INPUT_HEADER
+    else if (strcmp(subsystem, "input") == 0)
+    {
+        vtbl = &lnxev_vtbl;
+        other_vtbl = &hidraw_vtbl;
+    }
+#endif
+    else
+    {
+        WARN("Unexpected subsystem %s for %s\n", debugstr_a(subsystem), debugstr_a(devnode));
+        close(fd);
+        return;
+    }
+
     hiddev = udev_device_get_parent_with_subsystem_devtype(dev, "hid", NULL);
     if (hiddev)
     {
         const char *bcdDevice = NULL;
 #ifdef HAS_PROPER_INPUT_HEADER
-        const platform_vtbl *other_vtbl = NULL;
         DEVICE_OBJECT *dup = NULL;
-        if (strcmp(subsystem, "hidraw") == 0)
-            other_vtbl = &lnxev_vtbl;
-        else if (strcmp(subsystem, "input") == 0)
-            other_vtbl = &hidraw_vtbl;
 
         if (other_vtbl)
             dup = bus_enumerate_hid_devices(other_vtbl, check_same_device, dev);
@@ -1326,16 +1348,16 @@ static void try_add_device(struct udev_device *dev)
     TRACE("Found udev device %s (vid %04x, pid %04x, version %u, serial %s)\n",
           debugstr_a(devnode), vid, pid, version, debugstr_w(serial));
 
-    if (strcmp(subsystem, "hidraw") == 0)
+    if (vtbl == &hidraw_vtbl)
     {
         device = bus_create_hid_device(hidraw_busidW, vid, pid, input, version, 0, serial, is_gamepad,
-                                       &hidraw_vtbl, sizeof(struct platform_private), FALSE);
+                                       vtbl, sizeof(struct platform_private), FALSE);
     }
 #ifdef HAS_PROPER_INPUT_HEADER
-    else if (strcmp(subsystem, "input") == 0)
+    else if (vtbl == &lnxev_vtbl)
     {
         device = bus_create_hid_device(lnxev_busidW, vid, pid, input, version, 0, serial, is_gamepad,
-                                       &lnxev_vtbl, sizeof(struct wine_input_private), FALSE);
+                                       vtbl, sizeof(struct wine_input_private), FALSE);
     }
 #endif
 
@@ -1391,8 +1413,10 @@ static void try_add_device(struct udev_device *dev)
         private->vidpid.vid = vid;
         private->vidpid.pid = pid;
         private->bus_type = bus_type;
+        private->vtbl = vtbl;
         set_quirks(private);
+
 #ifdef HAS_PROPER_INPUT_HEADER
-        if (strcmp(subsystem, "input") == 0)
+        if (private->vtbl == &lnxev_vtbl)
             if (!build_report_descriptor((struct wine_input_private*)private, dev))
             {
@@ -1375,17 +1399,11 @@ static void try_remove_device(struct udev_device *dev)
 {
     DEVICE_OBJECT *device = NULL;
     struct platform_private* private;
-#ifdef HAS_PROPER_INPUT_HEADER
-    BOOL is_input = FALSE;
-#endif
 
     device = bus_find_hid_device(&hidraw_vtbl, dev);
 #ifdef HAS_PROPER_INPUT_HEADER
     if (device == NULL)
-    {
         device = bus_find_hid_device(&lnxev_vtbl, dev);
-        is_input = TRUE;
-    }
 #endif
     if (!device) return;
 
@@ -1402,7 +1420,7 @@ static void try_remove_device(struct udev_device *dev)
         close(private->control_pipe[1]);
         CloseHandle(private->report_thread);
 #ifdef HAS_PROPER_INPUT_HEADER
-        if (strcmp(udev_device_get_subsystem(dev), "input") == 0)
+        if (private->vtbl == &lnxev_vtbl)
         {
             HeapFree(GetProcessHeap(), 0, ((struct wine_input_private*)private)->current_report_buffer);
             HeapFree(GetProcessHeap(), 0, ((struct wine_input_private*)private)->last_report_buffer);
@@ -1411,7 +1429,7 @@ static void try_remove_device(struct udev_device *dev)
     }
 
 #ifdef HAS_PROPER_INPUT_HEADER
-    if (is_input)
+    if (private->vtbl == &lnxev_vtbl)
     {
         struct wine_input_private *ext = (struct wine_input_private*)private;
         HeapFree(GetProcessHeap(), 0, ext->report_descriptor);
From 2cc55dfaa6a14c832efc5be1ce564809ac6ac72c Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 14:29:16 +0000
Subject: [PATCH] winebus: Remove udev-backed devices by comparing their /dev
 nodes

This is a step towards being able to monitor /dev with inotify when
running in a container, where udev monitoring often doesn't work.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 46 +++++++++++++++++++++++++++++++++----
 1 file changed, 41 insertions(+), 5 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index a43c1c29d74..49058e584d9 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1442,23 +1442,48 @@ static void try_add_device(struct udev_device *dev)
     HeapFree(GetProcessHeap(), 0, serial);
 }
 
-static void try_remove_device(struct udev_device *dev)
+/* Return 0 to stop enumeration if @device's canonical path in /dev is @context. */
+static int stop_if_devnode_equals(DEVICE_OBJECT *device, void *context)
+{
+    struct platform_private *private = impl_from_DEVICE_OBJECT(device);
+    const char *want_devnode = context;
+    const char *devnode = udev_device_get_devnode(private->udev_device);
+
+    if (!devnode)
+        return 1;
+
+    if (strcmp(devnode, want_devnode) == 0)
+    {
+        TRACE("Found device %p with devnode %s\n", private, debugstr_a(want_devnode));
+        return 0;
+    }
+
+    return 1;
+}
+
+static void try_remove_device_by_devnode(const char *devnode)
 {
     DEVICE_OBJECT *device = NULL;
     struct platform_private* private;
+    struct udev_device *dev;
+
+    TRACE("Removing device if present: %s\n", debugstr_a(devnode));
+    device = bus_enumerate_hid_devices(&hidraw_vtbl, stop_if_devnode_equals, (void *) devnode);
 
-    device = bus_find_hid_device(&hidraw_vtbl, dev);
 #ifdef HAS_PROPER_INPUT_HEADER
     if (device == NULL)
-        device = bus_find_hid_device(&lnxev_vtbl, dev);
+        device = bus_enumerate_hid_devices(&lnxev_vtbl, stop_if_devnode_equals, (void *) devnode);
 #endif
     if (!device) return;
 
+    private = impl_from_DEVICE_OBJECT(device);
+    TRACE("Removing %s device: devnode %s udev_device %p -> %p\n",
+          (private->vtbl == &hidraw_vtbl ? "hidraw" : "evdev"),
+          debugstr_a(devnode), private->udev_device, private);
+
     bus_unlink_hid_device(device);
     IoInvalidateDeviceRelations(bus_pdo, BusRelations);
 
-    private = impl_from_DEVICE_OBJECT(device);
-
     if (private->report_thread)
     {
         write(private->control_pipe[1], "q", 1);
@@ -1489,6 +1514,17 @@ static void try_remove_device(struct udev_device *dev)
     udev_device_unref(dev);
 }
 
+static void try_remove_device(struct udev_device *dev)
+{
+    const char *devnode = udev_device_get_devnode(dev);
+
+    /* If it didn't have a device node, then we wouldn't be tracking it anyway */
+    if (!devnode)
+        return;
+
+    try_remove_device_by_devnode(devnode);
+}
+
 static void build_initial_deviceset(void)
 {
     struct udev_enumerate *enumerate;
From 0b9d8e2f5d323aaee11a26115e8aef4283db02e8 Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Wed, 11 Nov 2020 13:48:18 +0000
Subject: [PATCH] winebus: Make it more explicit how we are checking for
 duplicate devices

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 25 +++++++++++++++++++++----
 1 file changed, 21 insertions(+), 4 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 49058e584d9..76e9e50d143 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1176,9 +1176,23 @@ static const platform_vtbl lnxev_vtbl = {
 };
 #endif
 
-static int check_same_device(DEVICE_OBJECT *device, void* context)
+/* Return 0 to stop enumeration if @device's canonical path in /sys is @context. */
+static int stop_if_syspath_equals(DEVICE_OBJECT *device, void *context)
 {
-    return !compare_platform_device(device, context);
+    struct platform_private *private = impl_from_DEVICE_OBJECT(device);
+    const char *want_syspath = context;
+    const char *syspath = udev_device_get_syspath(private->udev_device);
+
+    if (!syspath)
+        return 1;
+
+    if (strcmp(syspath, want_syspath) == 0)
+    {
+        TRACE("Found device %p with syspath %s\n", private, debugstr_a(want_syspath));
+        return 0;
+    }
+
+    return 1;
 }
 
 static DWORD a_to_bcd(const char *s)
@@ -1273,6 +1287,7 @@ static void try_add_device(struct udev_device *dev)
 #ifdef HAS_PROPER_INPUT_HEADER
     const platform_vtbl *other_vtbl = NULL;
 #endif
+    const char *syspath;
 
     if (!(devnode = udev_device_get_devnode(dev)))
         return;
@@ -1283,6 +1298,7 @@ static void try_add_device(struct udev_device *dev)
         return;
     }
 
+    syspath = udev_device_get_syspath(dev);
     subsystem = udev_device_get_subsystem(dev);
 
     if (strcmp(subsystem, "hidraw") == 0)
@@ -1314,10 +1330,11 @@ static void try_add_device(struct udev_device *dev)
         DEVICE_OBJECT *dup = NULL;
 
         if (other_vtbl)
-            dup = bus_enumerate_hid_devices(other_vtbl, check_same_device, dev);
+            dup = bus_enumerate_hid_devices(other_vtbl, stop_if_syspath_equals, (void *) syspath);
         if (dup)
         {
-            TRACE("Duplicate cross bus device (%p) found, not adding the new one\n", dup);
+            TRACE("Duplicate cross bus device %s (%p) found, not adding the new one\n",
+                  debugstr_a(syspath), dup);
             close(fd);
             return;
         }
From 536db43874def5b4aed25573b862c0ea9990958a Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Wed, 11 Nov 2020 13:49:50 +0000
Subject: [PATCH] winebus: Treat udev actions other than "remove" as "add"

As per https://github.com/systemd/systemd/blob/v247-rc1/NEWS#L5
there are more kernel uevent types than just "add" and "remove",
and we should be treating everything other than "remove" as being
potentially an "add".

To cope with this, try_add_device() now checks whether the same device
was already added. If so, we ignore it.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 16 +++++++++++-----
 1 file changed, 11 insertions(+), 5 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 76e9e50d143..f63389a8da8 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1276,6 +1276,7 @@ static void try_add_device(struct udev_device *dev)
     DWORD vid = 0, pid = 0, version = 0, bus_type = 0;
     struct udev_device *hiddev = NULL, *walk_device;
     DEVICE_OBJECT *device = NULL;
+    DEVICE_OBJECT *dup = NULL;
     const char *subsystem;
     const char *devnode;
     WCHAR *serial = NULL;
@@ -1322,13 +1323,20 @@ static void try_add_device(struct udev_device *dev)
         return;
     }
 
+    dup = bus_enumerate_hid_devices(vtbl, stop_if_syspath_equals, (void *) syspath);
+    if (dup)
+    {
+        TRACE("Duplicate %s device (%p) found, not adding the new one\n",
+              debugstr_a(syspath), dup);
+        close(fd);
+        return;
+    }
+
     hiddev = udev_device_get_parent_with_subsystem_devtype(dev, "hid", NULL);
     if (hiddev)
     {
         const char *bcdDevice = NULL;
 #ifdef HAS_PROPER_INPUT_HEADER
-        DEVICE_OBJECT *dup = NULL;
-
         if (other_vtbl)
             dup = bus_enumerate_hid_devices(other_vtbl, stop_if_syspath_equals, (void *) syspath);
         if (dup)
@@ -1652,12 +1660,10 @@ static void process_monitor_event(struct udev_monitor *monitor)
 
     if (!action)
         WARN("No action received\n");
-    else if (strcmp(action, "add") == 0)
-        try_add_device(dev);
     else if (strcmp(action, "remove") == 0)
         try_remove_device(dev);
     else
-        WARN("Unhandled action %s\n", debugstr_a(action));
+        try_add_device(dev);
 
     udev_device_unref(dev);
 }
From 953a492517f3e2ebc36c2cd2f25ee2df5fc78018 Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 15:19:59 +0000
Subject: [PATCH] winebus: Disable evdev at runtime, not at build time

This lets us try out the evdev code path, even in Proton.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index f63389a8da8..67272ce4723 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -48,7 +48,7 @@
 # include <linux/input.h>
 # undef SW_MAX
 # if defined(EVIOCGBIT) && defined(EV_ABS) && defined(BTN_PINKIE)
-//#  define HAS_PROPER_INPUT_HEADER
+#  define HAS_PROPER_INPUT_HEADER
 # endif
 # ifndef SYN_DROPPED
 #  define SYN_DROPPED 3
@@ -1746,9 +1746,9 @@ NTSTATUS udev_driver_init(void)
         TRACE("UDEV hidraw devices disabled in registry\n");
 
 #ifdef HAS_PROPER_INPUT_HEADER
-    disable_input = check_bus_option(&input_disabled, 0);
+    disable_input = check_bus_option(&input_disabled, 1);
     if (disable_input)
-        TRACE("UDEV input devices disabled in registry\n");
+        TRACE("UDEV input devices disabled in registry or by default\n");
 #endif
 
     if (!(events[0] = CreateEventW(NULL, TRUE, FALSE, NULL)))
From f7748a37c634d8261c58ba7a3d8ace07c716f235 Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 18:28:28 +0000
Subject: [PATCH] winebus: Add code path to bypass udevd and use inotify

In a container with a non-trivial user namespace, we cannot rely on
libudev communicating with udevd as a way to monitor device nodes,
for the following reasons:

* If uid 0 from the host is not mapped to uid 0 in the container, libudev
  cannot authenticate netlink messages from the host, because their sender
  uid appears to be the overflowuid. Resolving this by mapping uid 0 into
  the container is not allowed when creating user namespaces as an
  unprivileged user, and even when running as a privileged user, it might
  be desirable for the real uid 0 to not be mapped as a way to harden the
  security boundary between container and host.

* Depending on the container configuration, initial enumeration might
  not be able to read /run/udev from the host system. If it can't, sysfs
  attributes will still work because those are read directly from the
  kernel via sysfs, but udev properties coming from user-space rules
  (in particular ID_INPUT_JOYSTICK and friends) will appear to be missing.

* The protocols between udevd and libudev (netlink messages for monitoring,
  and /run/udev for initial enumeration) are considered to be private to
  a particular version of udev, and are not a stable API; but in a
  container, we cannot expect that our copy of libudev is at exactly the
  same version as udevd on the host system.

Sidestep this by adding a code path that continues to use libudev for
the parts that work regardless of whether udevd is running or can be
communicated with, but

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 328 ++++++++++++++++++++++++++++++++++--
 1 file changed, 315 insertions(+), 13 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 67272ce4723..f398d96818c 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -20,6 +20,8 @@
 
 #define _GNU_SOURCE
 #include "config.h"
+#include <sys/types.h>
+#include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
 #include <stdarg.h>
@@ -43,6 +45,9 @@
 #ifdef HAVE_SYS_IOCTL_H
 # include <sys/ioctl.h>
 #endif
+#ifdef HAVE_SYS_INOTIFY_H
+# include <sys/inotify.h>
+#endif
 
 #ifdef HAVE_LINUX_INPUT_H
 # include <linux/input.h>
@@ -91,6 +96,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(plugplay);
 WINE_DECLARE_DEBUG_CHANNEL(hid_report);
 
 static struct udev *udev_context = NULL;
+static DWORD bypass_udevd = 0;
 static DWORD disable_hidraw = 0;
 static DWORD disable_input = 0;
 static HANDLE deviceloop_handle;
@@ -1271,7 +1277,8 @@ static void set_quirks(struct platform_private *private)
             private->vidpid.pid, private->quirks);
 }
 
-static void try_add_device(struct udev_device *dev)
+static void try_add_device(struct udev_device *dev,
+                           int fd)
 {
     DWORD vid = 0, pid = 0, version = 0, bus_type = 0;
     struct udev_device *hiddev = NULL, *walk_device;
@@ -1282,7 +1289,6 @@ static void try_add_device(struct udev_device *dev)
     WCHAR *serial = NULL;
     BOOL is_gamepad = FALSE;
     WORD input = -1;
-    int fd;
     static const CHAR *base_serial = "0000";
     const platform_vtbl *vtbl = NULL;
 #ifdef HAS_PROPER_INPUT_HEADER
@@ -1291,12 +1297,21 @@ static void try_add_device(struct udev_device *dev)
     const char *syspath;
 
     if (!(devnode = udev_device_get_devnode(dev)))
+    {
+        if (fd >= 0)
+            close(fd);
+
         return;
+    }
 
-    if ((fd = open(devnode, O_RDWR)) == -1)
+    if (fd < 0)
     {
-        WARN("Unable to open udev device %s: %s\n", debugstr_a(devnode), strerror(errno));
-        return;
+
+        if ((fd = open(devnode, O_RDWR)) == -1)
+        {
+            WARN("Unable to open udev device %s: %s\n", debugstr_a(devnode), strerror(errno));
+            return;
+        }
     }
 
     syspath = udev_device_get_syspath(dev);
@@ -1550,7 +1565,149 @@ static void try_remove_device(struct udev_device *dev)
     try_remove_device_by_devnode(devnode);
 }
 
-static void build_initial_deviceset(void)
+/* inotify watch descriptors for create_monitor_direct() */
+#ifdef HAVE_SYS_INOTIFY_H
+static int dev_watch = -1;
+static int devinput_watch = -1;
+#endif
+
+static int str_has_prefix(const char *str,
+                          const char *prefix)
+{
+    return (strncmp(str, prefix, strlen(prefix)) == 0);
+}
+
+static int str_is_integer(const char *str)
+{
+    const char *p;
+
+    if (*str == '\0')
+        return 0;
+
+    for (p = str; *p != '\0'; p++)
+    {
+        if (*p < '0' || *p > '9')
+            return 0;
+    }
+
+    return 1;
+}
+
+static void maybe_add_devnode(const platform_vtbl *vtbl, const char *base, const char *dir,
+                              const char *base_should_be, const char *subsystem)
+{
+    const char *udev_devnode;
+    char devnode[MAX_PATH];
+    char syslink[MAX_PATH];
+    char *syspath = NULL;
+    struct udev_device *dev = NULL;
+    int fd = -1;
+
+    TRACE("Considering %s/%s...\n", dir, base);
+
+    if (!str_has_prefix(base, base_should_be))
+        return;
+
+    if (!str_is_integer(base + strlen(base_should_be)))
+        return;
+
+    snprintf(devnode, sizeof(devnode), "%s/%s", dir, base);
+    fd = open(devnode, O_RDWR);
+
+    if (fd < 0)
+    {
+        /* When using inotify monitoring, quietly ignore device nodes that we cannot read,
+         * without emitting a warning.
+         *
+         * We can expect that a significant number of device nodes will be permanently
+         * unreadable, such as the device nodes for keyboards and mice. We can also expect
+         * that joysticks and game controllers will be temporarily unreadable until udevd
+         * chmods them; we'll get another chance to open them when their attributes change. */
+        TRACE("Unable to open %s, ignoring: %s\n", debugstr_a(devnode), strerror(errno));
+        goto out;
+    }
+
+    snprintf(syslink, sizeof(syslink), "/sys/class/%s/%s", subsystem, base);
+    TRACE("Resolving real path to %s\n", debugstr_a(syslink));
+    syspath = realpath(syslink, NULL);
+
+    if (!syspath)
+    {
+        WARN("Unable to resolve path \"%s\" for \"%s/%s\": %s\n",
+             debugstr_a(syslink), dir, base, strerror(errno));
+        goto out;
+    }
+
+    TRACE("Creating udev_device for %s\n", syspath);
+    dev = udev_device_new_from_syspath(udev_context, syspath);
+    udev_devnode = udev_device_get_devnode(dev);
+
+    if (udev_devnode == NULL || strcmp(devnode, udev_devnode) != 0)
+    {
+        WARN("Tried to get udev device for \"%s\" but device node of \"%s\" -> \"%s\" is \"%s\"\n",
+             debugstr_a(devnode), debugstr_a(syslink), debugstr_a(syspath),
+             debugstr_a(udev_devnode));
+        goto out;
+    }
+
+    TRACE("Adding device for %s\n", syspath);
+    try_add_device(dev, fd);
+    /* ownership was taken */
+    fd = -1;
+
+out:
+    if (fd >= 0)
+        close(fd);
+    if (dev)
+        udev_device_unref(dev);
+    free(syspath);
+}
+
+static void build_initial_deviceset_direct(void)
+{
+    DIR *dir;
+    struct dirent *dent;
+
+    if (!disable_hidraw)
+    {
+        TRACE("Initial enumeration of /dev/hidraw*\n");
+        dir = opendir("/dev");
+
+        if (dir)
+        {
+            for (dent = readdir(dir); dent; dent = readdir(dir))
+                maybe_add_devnode(&hidraw_vtbl, dent->d_name, "/dev", "hidraw", "hidraw");
+
+            closedir(dir);
+        }
+        else
+        {
+            WARN("Unable to open /dev: %s\n", strerror(errno));
+        }
+    }
+
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!disable_input)
+    {
+        TRACE("Initial enumeration of /dev/input/event*\n");
+        dir = opendir("/dev/input");
+
+        if (dir)
+        {
+            for (dent = readdir(dir); dent; dent = readdir(dir))
+                maybe_add_devnode(&lnxev_vtbl, dent->d_name, "/dev/input", "event", "input");
+
+            closedir(dir);
+        }
+        else
+        {
+            WARN("Unable to open /dev/input: %s\n", strerror(errno));
+        }
+    }
+#endif
+}
+
+static void build_initial_deviceset_udevd(void)
 {
     struct udev_enumerate *enumerate;
     struct udev_list_entry *devices, *dev_list_entry;
@@ -1585,7 +1742,7 @@ static void build_initial_deviceset(void)
         path = udev_list_entry_get_name(dev_list_entry);
         if ((dev = udev_device_new_from_syspath(udev_context, path)))
         {
-            try_add_device(dev);
+            try_add_device(dev, -1);
             udev_device_unref(dev);
         }
     }
@@ -1593,6 +1750,67 @@ static void build_initial_deviceset(void)
     udev_enumerate_unref(enumerate);
 }
 
+static void create_inotify(struct pollfd *pfd)
+{
+#ifdef HAVE_SYS_INOTIFY_H
+    int systems = 0;
+
+    pfd->revents = 0;
+    pfd->fd = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
+
+    if (pfd->fd < 0)
+    {
+        WARN("Unable to get inotify fd\n");
+        goto error;
+    }
+
+    if (!disable_hidraw)
+    {
+        /* We need to watch for attribute changes in addition to
+         * creation, because when a device is first created, it has
+         * permissions that we can't read. When udev chmods it to
+         * something that we maybe *can* read, we'll get an
+         * IN_ATTRIB event to tell us. */
+        dev_watch = inotify_add_watch(pfd->fd, "/dev",
+                                      IN_CREATE | IN_DELETE | IN_MOVE | IN_ATTRIB);
+        if (dev_watch < 0)
+            WARN("Unable to initialize inotify for /dev: %s\n",
+                 strerror(errno));
+        else
+            systems++;
+    }
+#ifdef HAS_PROPER_INPUT_HEADER
+    if (!disable_input)
+    {
+        devinput_watch = inotify_add_watch(pfd[0].fd, "/dev/input",
+                                           IN_CREATE | IN_DELETE | IN_MOVE | IN_ATTRIB);
+        if (devinput_watch < 0)
+            WARN("Unable to initialize inotify for /dev/input: %s\n",
+                 strerror(errno));
+        else
+            systems++;
+    }
+#endif
+    if (systems == 0)
+    {
+        WARN("No subsystems added to monitor\n");
+        goto error;
+    }
+
+    pfd->events = POLLIN;
+    return;
+
+error:
+    WARN("Failed to start monitoring\n");
+    if (pfd->fd >= 0)
+        close(pfd->fd);
+    pfd->fd = -1;
+#else
+    WARN("Compiled without inotify support, cannot watch for new input devices\n");
+    pfd->fd = -1;
+#endif
+}
+
 static struct udev_monitor *create_monitor(struct pollfd *pfd)
 {
     struct udev_monitor *monitor;
@@ -1642,6 +1860,71 @@ static struct udev_monitor *create_monitor(struct pollfd *pfd)
     return NULL;
 }
 
+static void maybe_remove_devnode(const char *base, const char *dir, const char *base_should_be)
+{
+    char path[MAX_PATH];
+
+    TRACE("Considering %s/%s...\n", dir, base);
+
+    if (!str_has_prefix(base, base_should_be))
+        return;
+
+    if (!str_is_integer(base + strlen(base_should_be)))
+        return;
+
+    snprintf(path, sizeof(path), "%s/%s", dir, base);
+    try_remove_device_by_devnode(path);
+}
+
+static void process_inotify_event(int fd)
+{
+#ifdef HAVE_SYS_INOTIFY_H
+    union
+    {
+        struct inotify_event event;
+        char storage[4096];
+        char enough_for_inotify[sizeof(struct inotify_event) + NAME_MAX + 1];
+    } buf;
+    ssize_t bytes;
+    size_t remain = 0;
+    size_t len;
+
+    bytes = read(fd, &buf, sizeof(buf));
+
+    if (bytes > 0)
+        remain = (size_t) bytes;
+
+    while (remain > 0)
+    {
+        if (buf.event.len > 0)
+        {
+            if (buf.event.wd == dev_watch)
+            {
+                if (buf.event.mask & (IN_CREATE | IN_MOVED_TO | IN_ATTRIB))
+                    maybe_add_devnode(&hidraw_vtbl, buf.event.name, "/dev", "hidraw", "hidraw");
+                else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM))
+                    maybe_remove_devnode(buf.event.name, "/dev", "hidraw");
+            }
+#ifdef HAS_PROPER_INPUT_HEADER
+            else if (buf.event.wd == devinput_watch)
+            {
+                if (buf.event.mask & (IN_CREATE | IN_MOVED_TO | IN_ATTRIB))
+                    maybe_add_devnode(&lnxev_vtbl, buf.event.name, "/dev/input", "event", "input");
+                else if (buf.event.mask & (IN_DELETE | IN_MOVED_FROM))
+                    maybe_remove_devnode(buf.event.name, "/dev/input", "event");
+            }
+#endif
+        }
+
+        len = sizeof(struct inotify_event) + buf.event.len;
+        remain -= len;
+
+        if (remain != 0)
+            memmove(&buf.storage[0], &buf.storage[len], remain);
+    }
+#endif
+}
+
 static void process_monitor_event(struct udev_monitor *monitor)
 {
     struct udev_device *dev;
@@ -1663,14 +1946,14 @@ static void process_monitor_event(struct udev_monitor *monitor)
     else if (strcmp(action, "remove") == 0)
         try_remove_device(dev);
     else
-        try_add_device(dev);
+        try_add_device(dev, -1);
 
     udev_device_unref(dev);
 }
 
 static DWORD CALLBACK deviceloop_thread(void *args)
 {
-    struct udev_monitor *monitor;
+    struct udev_monitor *monitor = NULL;
     HANDLE init_done = args;
     struct pollfd pfd[2];
 
@@ -1678,15 +1961,28 @@ static DWORD CALLBACK deviceloop_thread(void *args)
     pfd[1].events = POLLIN;
     pfd[1].revents = 0;
 
-    monitor = create_monitor(&pfd[0]);
-    build_initial_deviceset();
+    if (bypass_udevd)
+    {
+        create_inotify(&pfd[0]);
+        build_initial_deviceset_direct();
+    }
+    else
+    {
+        monitor = create_monitor(&pfd[0]);
+        build_initial_deviceset_udevd();
+    }
+
     SetEvent(init_done);
 
-    while (monitor)
+    while (pfd[0].fd >= 0)
     {
         if (poll(pfd, 2, -1) <= 0) continue;
         if (pfd[1].revents) break;
-        process_monitor_event(monitor);
+
+        if (monitor)
+            process_monitor_event(monitor);
+        else
+            process_inotify_event(pfd[0].fd);
     }
 
     TRACE("Monitor thread exiting\n");
@@ -1724,6 +2020,8 @@ NTSTATUS udev_driver_init(void)
 {
     HANDLE events[2];
     DWORD result;
+    static const WCHAR disable_udevdW[] = {'D','i','s','a','b','l','e','U','d','e','v','d',0};
+    static const UNICODE_STRING disable_udevd = {sizeof(disable_udevdW) - sizeof(WCHAR), sizeof(disable_udevdW), (WCHAR*)disable_udevdW};
     static const WCHAR hidraw_disabledW[] = {'D','i','s','a','b','l','e','H','i','d','r','a','w',0};
     static const UNICODE_STRING hidraw_disabled = {sizeof(hidraw_disabledW) - sizeof(WCHAR), sizeof(hidraw_disabledW), (WCHAR*)hidraw_disabledW};
     static const WCHAR input_disabledW[] = {'D','i','s','a','b','l','e','I','n','p','u','t',0};
@@ -1741,6 +2039,10 @@ NTSTATUS udev_driver_init(void)
         goto error;
     }
 
+    bypass_udevd = check_bus_option(&disable_udevd, 0);
+    if (bypass_udevd)
+        TRACE("udev disabled, falling back to inotify\n");
+
     disable_hidraw = check_bus_option(&hidraw_disabled, 0);
     if (disable_hidraw)
         TRACE("UDEV hidraw devices disabled in registry\n");
From 333f50170f2c785f1be58315727cf5e264c4d2ba Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 18:32:28 +0000
Subject: [PATCH] winebus: Automatically bypass udevd in Flatpak or
 pressure-vessel

Flatpak uses unprivileged containers that don't normally map uid 0
into the container, so netlink events won't work there, as described
in previous commits. Steam's pressure-vessel container tool behaves
similarly.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index f398d96818c..bf6ed61b2e2 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -2039,7 +2039,14 @@ NTSTATUS udev_driver_init(void)
         goto error;
     }
 
-    bypass_udevd = check_bus_option(&disable_udevd, 0);
+    if (access ("/run/pressure-vessel", R_OK)
+        || access ("/.flatpak-info", R_OK))
+    {
+        TRACE("Container detected, bypassing udevd by default\n");
+        bypass_udevd = 1;
+    }
+
+    bypass_udevd = check_bus_option(&disable_udevd, bypass_udevd);
     if (bypass_udevd)
         TRACE("udev disabled, falling back to inotify\n");
 From 1eb53f3eb1ba81e00dcbe52eb1078e6db7a75821 Mon Sep 17 00:00:00 2001
From: Simon McVittie <smcv@collabora.com>
Date: Tue, 10 Nov 2020 19:03:47 +0000
Subject: [PATCH] winebus: Guess the type of evdev input devices

Ordinarily, we can get the type of an evdev input device from udev:
the input_id builtin sets udev properties of the form ID_INPUT_FOO
that we can read.

However, in a container there is no guarantee that the libudev in the
container will interoperate with the udevd on the host system, so we
need to be prepared to do this ourselves from first principles, using
a heuristic similar to the one in udev's input_id.

We cannot simply copy the heuristic from udev's input_id, because its
licensing is incompatible (GPL). Instead, use a vaguely similar heuristic
that works from the same inputs and will generally produce similar results.

Signed-off-by: Simon McVittie <smcv@collabora.com>
---
 dlls/winebus.sys/bus_udev.c | 331 +++++++++++++++++++++++++++++++++++-
 1 file changed, 329 insertions(+), 2 deletions(-)

diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index bf6ed61b2e2..cc332c6f042 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -24,6 +24,7 @@
 #include <dirent.h>
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <stdarg.h>
 #include <stdlib.h>
 #include <stdio.h>
@@ -259,7 +260,304 @@ static BYTE *add_axis_block(BYTE *report_ptr, BYTE count, BYTE page, BYTE *usage
     return report_ptr;
 }
 
-static const BYTE* what_am_I(struct udev_device *dev)
+/* Minimal compatibility with code taken from steam-runtime-tools */
+typedef int gboolean;
+#define g_debug(fmt, ...) TRACE(fmt "\n", ## __VA_ARGS__)
+#define G_N_ELEMENTS(arr) (sizeof(arr)/sizeof(arr[0]))
+
+typedef enum
+{
+  SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK = (1 << 0),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER = (1 << 1),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD = (1 << 2),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS = (1 << 3),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE = (1 << 4),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD = (1 << 5),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN = (1 << 6),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET = (1 << 7),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET_PAD = (1 << 8),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK = (1 << 9),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH = (1 << 10),
+  SRT_INPUT_DEVICE_TYPE_FLAGS_NONE = 0
+} SrtInputDeviceTypeFlags;
+
+#define BITS_PER_LONG           (sizeof (unsigned long) * CHAR_BIT)
+#define LONGS_FOR_BITS(x)       ((((x)-1)/BITS_PER_LONG)+1)
+typedef struct
+{
+  unsigned long ev[LONGS_FOR_BITS (EV_MAX)];
+  unsigned long keys[LONGS_FOR_BITS (KEY_MAX)];
+  unsigned long abs[LONGS_FOR_BITS (ABS_MAX)];
+  unsigned long rel[LONGS_FOR_BITS (REL_MAX)];
+  unsigned long ff[LONGS_FOR_BITS (FF_MAX)];
+  unsigned long props[LONGS_FOR_BITS (INPUT_PROP_MAX)];
+} SrtEvdevCapabilities;
+
+static gboolean
+_srt_get_caps_from_evdev (int fd,
+                          unsigned int type,
+                          unsigned long *bitmask,
+                          size_t bitmask_len_longs)
+{
+  size_t bitmask_len_bytes = bitmask_len_longs * sizeof (*bitmask);
+
+  memset (bitmask, 0, bitmask_len_bytes);
+
+  if (ioctl (fd, EVIOCGBIT (type, bitmask_len_bytes), bitmask) < 0)
+    return FALSE;
+
+  return TRUE;
+}
+
+static gboolean
+_srt_evdev_capabilities_set_from_evdev (SrtEvdevCapabilities *caps,
+                                        int fd)
+{
+  if (_srt_get_caps_from_evdev (fd, 0, caps->ev, G_N_ELEMENTS (caps->ev)))
+    {
+      _srt_get_caps_from_evdev (fd, EV_KEY, caps->keys, G_N_ELEMENTS (caps->keys));
+      _srt_get_caps_from_evdev (fd, EV_ABS, caps->abs, G_N_ELEMENTS (caps->abs));
+      _srt_get_caps_from_evdev (fd, EV_REL, caps->rel, G_N_ELEMENTS (caps->rel));
+      _srt_get_caps_from_evdev (fd, EV_FF, caps->ff, G_N_ELEMENTS (caps->ff));
+      ioctl (fd, EVIOCGPROP (sizeof (caps->props)), caps->props);
+      return TRUE;
+    }
+
+  memset (caps, 0, sizeof (*caps));
+  return FALSE;
+}
+
+#define JOYSTICK_ABS_AXES \
+  ((1 << ABS_X) | (1 << ABS_Y) \
+   | (1 << ABS_RX) | (1 << ABS_RY) \
+   | (1 << ABS_THROTTLE) | (1 << ABS_RUDDER) \
+   | (1 << ABS_WHEEL) | (1 << ABS_GAS) | (1 << ABS_BRAKE) \
+   | (1 << ABS_HAT0X) | (1 << ABS_HAT0Y) \
+   | (1 << ABS_HAT1X) | (1 << ABS_HAT1Y) \
+   | (1 << ABS_HAT2X) | (1 << ABS_HAT2Y) \
+   | (1 << ABS_HAT3X) | (1 << ABS_HAT3Y))
+
+static const unsigned int first_mouse_button = BTN_MOUSE;
+static const unsigned int last_mouse_button = BTN_JOYSTICK - 1;
+
+static const unsigned int first_joystick_button = BTN_JOYSTICK;
+static const unsigned int last_joystick_button = BTN_GAMEPAD - 1;
+
+static const unsigned int first_gamepad_button = BTN_GAMEPAD;
+static const unsigned int last_gamepad_button = BTN_DIGI - 1;
+
+static const unsigned int first_dpad_button = BTN_DPAD_UP;
+static const unsigned int last_dpad_button = BTN_DPAD_RIGHT;
+
+static const unsigned int first_extra_joystick_button = BTN_TRIGGER_HAPPY;
+static const unsigned int last_extra_joystick_button = BTN_TRIGGER_HAPPY40;
+
+SrtInputDeviceTypeFlags
+_srt_evdev_capabilities_guess_type (const SrtEvdevCapabilities *caps)
+{
+  SrtInputDeviceTypeFlags flags = SRT_INPUT_DEVICE_TYPE_FLAGS_NONE;
+  unsigned int i;
+  gboolean has_joystick_axes = FALSE;
+  gboolean has_joystick_buttons = FALSE;
+
+  /* Some properties let us be fairly sure about a device */
+  if (test_bit (caps->props, INPUT_PROP_ACCELEROMETER))
+    {
+      g_debug ("INPUT_PROP_ACCELEROMETER => is accelerometer");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+    }
+
+  if (test_bit (caps->props, INPUT_PROP_POINTING_STICK))
+    {
+      g_debug ("INPUT_PROP_POINTING_STICK => is pointing stick");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK;
+    }
+
+  if (test_bit (caps->props, INPUT_PROP_BUTTONPAD)
+      || test_bit (caps->props, INPUT_PROP_TOPBUTTONPAD))
+    {
+      g_debug ("INPUT_PROP_[TOP]BUTTONPAD => is touchpad");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
+    }
+
+  /* Devices with a stylus or pen are assumed to be graphics tablets */
+  if (test_bit (caps->keys, BTN_STYLUS)
+      || test_bit (caps->keys, BTN_TOOL_PEN))
+    {
+      g_debug ("Stylus or pen => is tablet");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET;
+    }
+
+  /* Devices that accept a finger touch are assumed to be touchpads or
+   * touchscreens.
+   *
+   * In Steam we mostly only care about these as a way to
+   * reject non-joysticks, so we're not very precise here yet.
+   *
+   * SDL assumes that TOUCH means a touchscreen and FINGER
+   * means a touchpad. */
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE
+      && (test_bit (caps->keys, BTN_TOOL_FINGER)
+          || test_bit (caps->keys, BTN_TOUCH)
+          || test_bit (caps->props, INPUT_PROP_SEMI_MT)))
+    {
+      g_debug ("Finger or touch or semi-MT => is touchpad or touchscreen");
+
+      if (test_bit (caps->props, INPUT_PROP_POINTER))
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD;
+      else
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN;
+    }
+
+  /* Devices with mouse buttons are ... probably mice? */
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
+    {
+      for (i = first_mouse_button; i <= last_mouse_button; i++)
+        {
+          if (test_bit (caps->keys, i))
+            {
+              g_debug ("Mouse button => mouse");
+              flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE;
+            }
+        }
+    }
+
+  if (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE)
+    {
+      for (i = ABS_X; i < ABS_Z; i++)
+        {
+          if (!test_bit (caps->abs, i))
+            break;
+        }
+
+      /* If it has 3 axes and no buttons it's probably an accelerometer. */
+      if (i == ABS_Z && !test_bit (caps->ev, EV_KEY))
+        {
+          g_debug ("3 left axes and no buttons => accelerometer");
+          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+        }
+
+      /* Same for RX..RZ (e.g. Wiimote) */
+      for (i = ABS_RX; i < ABS_RZ; i++)
+        {
+          if (!test_bit (caps->abs, i))
+            break;
+        }
+
+      if (i == ABS_RZ && !test_bit (caps->ev, EV_KEY))
+        {
+          g_debug ("3 right axes and no buttons => accelerometer");
+          flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_ACCELEROMETER;
+        }
+    }
+
+  /* Bits 1 to 31 are ESC, numbers and Q to D, which SDL and udev both
+   * consider to be enough to count as a fully-functioned keyboard. */
+  if ((caps->keys[0] & 0xfffffffe) == 0xfffffffe)
+    {
+      g_debug ("First few keys => keyboard");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD;
+    }
+
+  /* If we have *any* keys, consider it to be something a bit
+   * keyboard-like. Bits 0 to 63 are all keyboard keys.
+   * Make sure we stop before reaching KEY_UP which is sometimes
+   * used on game controller mappings, e.g. for the Wiimote. */
+  for (i = 0; i < (64 / BITS_PER_LONG); i++)
+    {
+      if (caps->keys[i] != 0)
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
+    }
+
+  if (caps->abs[0] & JOYSTICK_ABS_AXES)
+    has_joystick_axes = TRUE;
+
+  /* Flight stick buttons */
+  for (i = first_joystick_button; i <= last_joystick_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Gamepad buttons (Xbox, PS3, etc.) */
+  for (i = first_gamepad_button; i <= last_gamepad_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Gamepad digital dpad */
+  for (i = first_dpad_button; i <= last_dpad_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Steering wheel gear-change buttons */
+  for (i = BTN_GEAR_DOWN; i <= BTN_GEAR_UP; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  /* Reserved space for extra game-controller buttons, e.g. on Corsair
+   * gaming keyboards */
+  for (i = first_extra_joystick_button; i <= last_extra_joystick_button; i++)
+    {
+      if (test_bit (caps->keys, i))
+        has_joystick_buttons = TRUE;
+    }
+
+  if (test_bit (caps->keys, last_mouse_button))
+    {
+      /* Mice with a very large number of buttons can apparently
+       * overflow into the joystick-button space, but they're still not
+       * joysticks. */
+      has_joystick_buttons = FALSE;
+    }
+
+  /* TODO: Do we want to consider BTN_0 up to BTN_9 to be joystick buttons?
+   * libmanette and SDL look for BTN_1, udev does not.
+   *
+   * They're used by some game controllers, like BTN_1 and BTN_2 for the
+   * Wiimote, BTN_1..BTN_9 for the SpaceTec SpaceBall and BTN_0..BTN_3
+   * for Playstation dance pads, but they're also used by
+   * non-game-controllers like Logitech mice. For now we entirely ignore
+   * these buttons: they are not evidence that it's a joystick, but
+   * neither are they evidence that it *isn't* a joystick. */
+
+  /* We consider it to be a joystick if there is some evidence that it is,
+   * and no evidence that it's something else.
+   *
+   * Unlike SDL, we accept devices with only axes and no buttons as a
+   * possible joystick, unless they have X/Y/Z axes in which case we
+   * assume they're accelerometers. */
+  if ((has_joystick_buttons || has_joystick_axes)
+      && (flags == SRT_INPUT_DEVICE_TYPE_FLAGS_NONE))
+    {
+      g_debug ("Looks like a joystick");
+      flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK;
+    }
+
+  /* If we have *any* keys below BTN_MISC, consider it to be something
+   * a bit keyboard-like, but don't rule out *also* being considered
+   * to be a joystick (again for e.g. the Wiimote). */
+  for (i = 0; i < (BTN_MISC / BITS_PER_LONG); i++)
+    {
+      if (caps->keys[i] != 0)
+        flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS;
+    }
+
+  /* Also non-exclusive: don't rule out a device being a joystick and
+   * having a switch */
+  if (test_bit (caps->ev, EV_SW))
+    flags |= SRT_INPUT_DEVICE_TYPE_FLAGS_SWITCH;
+
+  return flags;
+}
+
+static const BYTE* what_am_I(struct udev_device *dev,
+                             int fd)
 {
     static const BYTE Unknown[2]     = {HID_USAGE_PAGE_GENERIC, 0};
     static const BYTE Mouse[2]       = {HID_USAGE_PAGE_GENERIC, HID_USAGE_GENERIC_MOUSE};
@@ -269,6 +567,7 @@ static const BYTE* what_am_I(struct udev_device *dev)
     static const BYTE Tablet[2]      = {HID_USAGE_PAGE_DIGITIZER, HID_USAGE_DIGITIZER_PEN};
     static const BYTE Touchscreen[2] = {HID_USAGE_PAGE_DIGITIZER, HID_USAGE_DIGITIZER_TOUCH_SCREEN};
     static const BYTE Touchpad[2]    = {HID_USAGE_PAGE_DIGITIZER, HID_USAGE_DIGITIZER_TOUCH_PAD};
+    SrtEvdevCapabilities caps;
 
     struct udev_device *parent = dev;
 
@@ -292,6 +591,34 @@ static const BYTE* what_am_I(struct udev_device *dev)
 
         parent = udev_device_get_parent_with_subsystem_devtype(parent, "input", NULL);
     }
+
+    /* In a container, udev properties might not be available. Fall back to deriving the device
+     * type from the fd's evdev capabilities. */
+    if (_srt_evdev_capabilities_set_from_evdev (&caps, fd))
+    {
+        SrtInputDeviceTypeFlags guessed_type;
+
+        guessed_type = _srt_evdev_capabilities_guess_type (&caps);
+
+        if (guessed_type & (SRT_INPUT_DEVICE_TYPE_FLAGS_MOUSE
+                            | SRT_INPUT_DEVICE_TYPE_FLAGS_POINTING_STICK))
+            return Mouse;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_KEYBOARD)
+            return Keyboard;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_JOYSTICK)
+            return Gamepad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_HAS_KEYS)
+            return Keypad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHPAD)
+            return Touchpad;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TOUCHSCREEN)
+            return Touchscreen;
+        else if (guessed_type & SRT_INPUT_DEVICE_TYPE_FLAGS_TABLET)
+            return Tablet;
+
+        /* Mapped to Unknown: ACCELEROMETER, TABLET_PAD, SWITCH. */
+    }
+
     return Unknown;
 }
 
@@ -425,7 +752,7 @@ static BOOL build_report_descriptor(struct wine_input_private *ext, struct udev_
     INT i, descript_size;
     INT report_size;
     INT button_count, abs_count, rel_count, hat_count;
-    const BYTE *device_usage = what_am_I(dev);
+    const BYTE *device_usage = what_am_I(dev, ext->base.device_fd);
 
     if (ioctl(ext->base.device_fd, EVIOCGBIT(EV_REL, sizeof(relbits)), relbits) == -1)
     {

