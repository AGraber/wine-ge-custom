From 7bd039f34f5fc1123524ddb22769f6e16e7d9c88 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 11 May 2017 10:01:16 -0500
Subject: [PATCH] HACK: ws2_32: Fake success when trying to bind to an IPX
 address

---
 dlls/ws2_32/socket.c | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 164a48ce751..b9248c9bd5e 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -3332,6 +3332,13 @@ int WINAPI WS_bind(SOCKET s, const struct WS_sockaddr* name, int namelen)
                     else if (interface_bind(s, fd, &uaddr.addr))
                         in4->sin_addr.s_addr = htonl(INADDR_ANY);
                 }
+
+                if(name->sa_family ==  WS_AF_IPX){
+                    /* Quake (and similar family) fails if we can't bind to an IPX address. This often
+                     * doesn't work on Linux, so just fake success. */
+                    return 0;
+                }
+
                 if (bind(fd, &uaddr.addr, uaddrlen) < 0)
                 {
                     int loc_errno = errno;

From 134fa05a0e39b63bfec75d0823ebe49e4c9cae64 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 7 Jun 2018 14:37:03 -0500
Subject: [PATCH] HACK: winex11.drv: Disable XIM by default

libx11 has a race condition that causes XIM to crash with "double free
or corruption" errors, see winehq bug 35041. Disabling XIM works around
this, though special input methods (CJK, etc.) will no longer work.
---
 dlls/winex11.drv/x11drv_main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index db87d188236..81a63a20689 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -93,7 +93,7 @@ static void *err_callback_arg;               /* error callback argument */
 static int err_callback_result;              /* error callback result */
 static unsigned long err_serial;             /* serial number of first request */
 static int (*old_error_handler)( Display *, XErrorEvent * );
-static BOOL use_xim = TRUE;
+static BOOL use_xim = FALSE;
 static char input_style[20];
 
 #define IS_OPTION_TRUE(ch) \
From 1091eaf13692b16ed66328ceeebfc587075fec6c Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 25 Oct 2018 12:50:45 -0500
Subject: [PATCH] HACK: wined3d: Fake an AMD card in place of Nvidia cards

Some games assume they can load the nvapi library if the hardware is an
nvidia card. This obviously fails in Wine. So fake that all nvidia
hardware is actually an AMD card, so they don't try to load nvapi.
---
 dlls/wined3d/adapter_gl.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/dlls/wined3d/adapter_gl.c b/dlls/wined3d/adapter_gl.c
index b8a2060cf46..8259d92ebac 100644
--- a/dlls/wined3d/adapter_gl.c
+++ b/dlls/wined3d/adapter_gl.c
@@ -1009,6 +1009,14 @@ static const struct wined3d_gpu_description *query_gpu_description(const struct
         vendor = wined3d_settings.pci_vendor_id;
         TRACE("Overriding vendor PCI ID with 0x%04x.\n", vendor);
     }
+    else if(vendor == HW_VENDOR_NVIDIA)
+    {
+        /* XXX: Fake having an AMD card in order to avoid games trying to load
+         * the Windows-only nvapi library. */
+        WARN("Nvidia card detected. Faking an AMD RX 480!\n");
+        vendor = HW_VENDOR_AMD;
+        device = CARD_AMD_RADEON_RX_480;
+    }
 
     if (wined3d_settings.pci_device_id != PCI_DEVICE_NONE)
     {

From aa7fa7ce94bd4e49e3843a8ea398d29882518e43 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 6 Aug 2018 08:06:03 -0500
Subject: [PATCH] server: Set default timeout to 0

The Steam client will be waiting for the wineserver to exit to set up
some environment variables, so make it wait as short as possible.
---
 server/main.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/server/main.c b/server/main.c
index 20d3c48c4d9..aca8738c4c0 100644
--- a/server/main.c
+++ b/server/main.c
@@ -42,7 +42,7 @@
 /* command-line options */
 int debug_level = 0;
 int foreground = 0;
-timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
+timeout_t master_socket_timeout = 0; /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
 /* parse-line args */

From ba15ba1c9b8ee40e13ef1bd7f018924259f36c1b Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 18 Jun 2018 07:56:35 -0500
Subject: [PATCH] ntdll: Notice THREADNAME_INFO exceptions and set thread name
 on Linux

Patch by Zeb.
---
 dlls/ntdll/unix/thread.c | 28 ++++++++++++++++++++++++++++
 1 file changed, 28 insertions(+)

diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index 3b451a22577..ca5dac43bb0 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -43,6 +43,9 @@
 #ifdef HAVE_SYS_SYSCALL_H
 #include <sys/syscall.h>
 #endif
+#ifdef HAVE_PRCTL
+#include <sys/prctl.h>
+#endif
 
 #define NONAMELESSUNION
 #include "ntstatus.h"
@@ -344,6 +347,16 @@ void wait_suspend( CONTEXT *context )
 }
 
 
+/* "How to: Set a Thread Name in Native Code"
+ * https://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx */
+typedef struct tagTHREADNAME_INFO
+{
+   DWORD   dwType;     /* Must be 0x1000 */
+   LPCSTR  szName;     /* Pointer to name - limited to 9 bytes (8 characters + terminator) */
+   DWORD   dwThreadID; /* Thread ID (-1 = caller thread) */
+   DWORD   dwFlags;    /* Reserved for future use.  Must be zero. */
+} THREADNAME_INFO;
+
 /**********************************************************************
  *           send_debug_event
  *
@@ -366,6 +379,21 @@ NTSTATUS send_debug_event( EXCEPTION_RECORD *rec, CONTEXT *context, BOOL first_c
     for (i = 0; i < min( rec->NumberParameters, EXCEPTION_MAXIMUM_PARAMETERS ); i++)
         params[i] = rec->ExceptionInformation[i];
 
+    if (rec->ExceptionCode == 0x406d1388)
+    {
+        const THREADNAME_INFO *threadname = (const THREADNAME_INFO *)rec->ExceptionInformation;
+
+        if (threadname->dwThreadID == -1)
+        {
+#ifdef HAVE_PRCTL
+#ifndef PR_SET_NAME
+# define PR_SET_NAME 15
+#endif
+            prctl( PR_SET_NAME, threadname->szName );
+#endif
+        }
+    }
+
     SERVER_START_REQ( queue_exception_event )
     {
         req->first   = first_chance;
From 7e91b897e69854cb3afe761f48ef7c9b496ecf95 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?J=C3=B3zef=20Kucia?= <jkucia@codeweavers.com>
Date: Wed, 1 May 2019 12:28:12 +0200
Subject: [PATCH] vulkan-1: Prefer built-in DLL.

Games may ship with their own Vulkan loader.
---
 dlls/vulkan-1/vulkan.c | 4 ----
 1 file changed, 4 deletions(-)

diff --git a/dlls/vulkan-1/vulkan.c b/dlls/vulkan-1/vulkan.c
index d3b35603a17..4926cf9bf4f 100644
--- a/dlls/vulkan-1/vulkan.c
+++ b/dlls/vulkan-1/vulkan.c
@@ -32,10 +32,6 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD reason, void *reserved)
 
     switch (reason)
     {
-        case DLL_WINE_PREATTACH:
-            /* Prefer native as it provides more functionality. */
-            return FALSE;
-
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinst);
             return TRUE;
From e485252dfad51a7e463643d56fe138129597e4b6 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 23 Sep 2019 08:56:04 -0500
Subject: [PATCH] ntdll: Always add a tail to heap allocations.

Fixes the Rockstar Games Launcher installer (and possibly other
NSIS-based installers) from crashing due to passing a too-small buffer
to GetWindowInfo().
---
 dlls/ntdll/heap.c | 11 +++++------
 1 file changed, 5 insertions(+), 6 deletions(-)

diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index 6344157f384..6fefe5d6d80 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -118,9 +118,8 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 #define HEAP_MIN_SHRINK_SIZE  (HEAP_MIN_DATA_SIZE+sizeof(ARENA_FREE))
 /* minimum size to start allocating large blocks */
 #define HEAP_MIN_LARGE_BLOCK_SIZE  0x7f000
-/* extra size to add at the end of block for tail checking */
-#define HEAP_TAIL_EXTRA_SIZE(flags) \
-    ((flags & HEAP_TAIL_CHECKING_ENABLED) || RUNNING_ON_VALGRIND ? ALIGNMENT : 0)
+/* extra size to add at the end of block to mitigate overruns and allow tail checking */
+#define HEAP_TAIL_EXTRA_SIZE ALIGNMENT
 
 /* size of the blocks on the free lists */
 #define HEAP_FREELIST_SIZE(index) \
@@ -800,7 +799,7 @@ static void HEAP_ShrinkBlock(SUBHEAP *subheap, ARENA_INUSE *pArena, SIZE_T size)
 static void *allocate_large_block( HEAP *heap, DWORD flags, SIZE_T size )
 {
     ARENA_LARGE *arena;
-    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    SIZE_T block_size = sizeof(*arena) + ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     LPVOID address = NULL;
 
     if (block_size < size) return NULL;  /* overflow */
@@ -1814,7 +1813,7 @@ void * WINAPI DECLSPEC_HOTPATCH RtlAllocateHeap( HANDLE heap, ULONG flags, SIZE_
     if (!heapPtr) return NULL;
     flags &= HEAP_GENERATE_EXCEPTIONS | HEAP_NO_SERIALIZE | HEAP_ZERO_MEMORY;
     flags |= heapPtr->flags;
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE( flags );
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size)  /* overflow */
     {
         if (flags & HEAP_GENERATE_EXCEPTIONS) RtlRaiseStatus( STATUS_NO_MEMORY );
@@ -1968,7 +1967,7 @@ PVOID WINAPI RtlReAllocateHeap( HANDLE heap, ULONG flags, PVOID ptr, SIZE_T size
     flags |= heapPtr->flags;
     if (!(flags & HEAP_NO_SERIALIZE)) enter_critical_section( &heapPtr->critSection );
 
-    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE(flags);
+    rounded_size = ROUND_SIZE(size) + HEAP_TAIL_EXTRA_SIZE;
     if (rounded_size < size) goto oom;  /* overflow */
     if (rounded_size < HEAP_MIN_DATA_SIZE) rounded_size = HEAP_MIN_DATA_SIZE;
 
From 90e3616c89ef7ed38763a3e3af3e9f0cd59697da Mon Sep 17 00:00:00 2001
From: Nikolay Sivov <nsivov@codeweavers.com>
Date: Wed, 8 Mar 2017 20:15:40 +0300
Subject: [PATCH] HACK: dwrite: Don't recommend outline rendering mode

---
 dlls/dwrite/font.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index e22559912c3..41ec809b727 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -740,7 +740,8 @@ static HRESULT WINAPI dwritefontface_GetRecommendedRenderingMode(IDWriteFontFace
 
     ppem = emSize * ppdip;
 
-    if (ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
+    /* HACK: disable outline rendering mode to workaround d2d issue */
+    if (0 && ppem >= RECOMMENDED_OUTLINE_AA_THRESHOLD) {
         *mode = DWRITE_RENDERING_MODE_OUTLINE;
         return S_OK;
     }
From 5c59517008697ce74becddb59a3e6702a963bb49 Mon Sep 17 00:00:00 2001
From: Zhiyi Zhang <zzhang@codeweavers.com>
Date: Fri, 16 Aug 2019 09:46:25 +0000
Subject: [PATCH] msctf: Use list to keep thread managers.

Thread managers were stored in thread local storage,
which have a major flaw that they can't not be released
by another thread.

Signed-off-by: Zhiyi Zhang <zzhang@codeweavers.com>
---
 dlls/msctf/msctf.c          | 46 +++++++----------------
 dlls/msctf/msctf_internal.h |  1 -
 dlls/msctf/threadmgr.c      | 73 ++++++++++++++++++++++++++++++++-----
 3 files changed, 76 insertions(+), 44 deletions(-)

diff --git a/dlls/msctf/msctf.c b/dlls/msctf/msctf.c
index c6e3a2ca597..fd919295c5a 100644
--- a/dlls/msctf/msctf.c
+++ b/dlls/msctf/msctf.c
@@ -69,7 +69,6 @@ static UINT array_size;
 static struct list AtsList = LIST_INIT(AtsList);
 static UINT activated = 0;
 
-DWORD tlsIndex = 0;
 TfClientId processId = 0;
 ITfCompartmentMgr *globalCompartmentMgr = NULL;
 
@@ -397,23 +396,19 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
     ActivatedTextService *actsvr;
     ITfCategoryMgr *catmgr;
     AtsEntry *entry;
-    ITfThreadMgrEx *tm = TlsGetValue(tlsIndex);
+    ITfThreadMgr *tm;
     ITfClientId *clientid;
 
-    if (!tm) return E_UNEXPECTED;
+    if (FAILED(TF_GetThreadMgr(&tm))) return E_UNEXPECTED;
 
     actsvr = HeapAlloc(GetProcessHeap(),0,sizeof(ActivatedTextService));
-    if (!actsvr) return E_OUTOFMEMORY;
+    if (!actsvr) goto fail;
 
-    ITfThreadMgrEx_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
+    ITfThreadMgr_QueryInterface(tm, &IID_ITfClientId, (void **)&clientid);
     ITfClientId_GetClientId(clientid, &lp->clsid, &actsvr->tid);
     ITfClientId_Release(clientid);
 
-    if (!actsvr->tid)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!actsvr->tid) goto fail;
 
     actsvr->pITfTextInputProcessor = NULL;
     actsvr->LanguageProfile = *lp;
@@ -440,20 +435,21 @@ HRESULT add_active_textservice(TF_LANGUAGEPROFILE *lp)
         deactivate_remove_conflicting_ts(&actsvr->LanguageProfile.catid);
 
     if (activated > 0)
-        activate_given_ts(actsvr, tm);
+        activate_given_ts(actsvr, (ITfThreadMgrEx *)tm);
 
     entry = HeapAlloc(GetProcessHeap(),0,sizeof(AtsEntry));
-
-    if (!entry)
-    {
-        HeapFree(GetProcessHeap(),0,actsvr);
-        return E_OUTOFMEMORY;
-    }
+    if (!entry) goto fail;
 
     entry->ats = actsvr;
     list_add_head(&AtsList, &entry->entry);
 
+    ITfThreadMgr_Release(tm);
     return S_OK;
+
+fail:
+    ITfThreadMgr_Release(tm);
+    HeapFree(GetProcessHeap(), 0, actsvr);
+    return E_OUTOFMEMORY;
 }
 
 BOOL get_active_textservice(REFCLSID rclsid, TF_LANGUAGEPROFILE *profile)
@@ -560,11 +556,9 @@ BOOL WINAPI DllMain(HINSTANCE hinst, DWORD fdwReason, LPVOID fImpLoad)
             return FALSE;   /* prefer native version */
         case DLL_PROCESS_ATTACH:
             MSCTF_hinstance = hinst;
-            tlsIndex = TlsAlloc();
             break;
         case DLL_PROCESS_DETACH:
             if (fImpLoad) break;
-            TlsFree(tlsIndex);
             break;
     }
     return TRUE;
@@ -622,20 +616,6 @@ HRESULT WINAPI TF_CreateThreadMgr(ITfThreadMgr **pptim)
     return ThreadMgr_Constructor(NULL,(IUnknown**)pptim);
 }
 
-/***********************************************************************
- *              TF_GetThreadMgr (MSCTF.@)
- */
-HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
-{
-    TRACE("\n");
-    *pptim = TlsGetValue(tlsIndex);
-
-    if (*pptim)
-        ITfThreadMgr_AddRef(*pptim);
-
-    return S_OK;
-}
-
 /***********************************************************************
  *              SetInputScope(MSCTF.@)
  */
diff --git a/dlls/msctf/msctf_internal.h b/dlls/msctf/msctf_internal.h
index 584bb1044ed..ace2bee23d9 100644
--- a/dlls/msctf/msctf_internal.h
+++ b/dlls/msctf/msctf_internal.h
@@ -35,7 +35,6 @@
 #define COOKIE_MAGIC_UIELEMENTSINK 0x00a0
 #define COOKIE_MAGIC_INPUTPROCESSORPROFILEACTIVATIONSINK 0x00b0
 
-extern DWORD tlsIndex DECLSPEC_HIDDEN;
 extern TfClientId processId DECLSPEC_HIDDEN;
 extern ITfCompartmentMgr *globalCompartmentMgr DECLSPEC_HIDDEN;
 
diff --git a/dlls/msctf/threadmgr.c b/dlls/msctf/threadmgr.c
index 2c208fbc04f..2119ea2193b 100644
--- a/dlls/msctf/threadmgr.c
+++ b/dlls/msctf/threadmgr.c
@@ -37,6 +37,17 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(msctf);
 
+static CRITICAL_SECTION ThreadMgrCs;
+static CRITICAL_SECTION_DEBUG ThreadMgrCsDebug =
+{
+    0, 0, &ThreadMgrCs,
+    {&ThreadMgrCsDebug.ProcessLocksList,
+     &ThreadMgrCsDebug.ProcessLocksList },
+     0, 0, {(DWORD_PTR)(__FILE__ ": ThreadMgrCs")}
+};
+static CRITICAL_SECTION ThreadMgrCs = {&ThreadMgrCsDebug, -1, 0, 0, 0, 0};
+struct list ThreadMgrList = LIST_INIT(ThreadMgrList);
+
 typedef struct tagPreservedKey
 {
     struct list     entry;
@@ -98,6 +109,9 @@ typedef struct tagACLMulti {
     struct list     ThreadMgrEventSink;
     struct list     UIElementSink;
     struct list     InputProcessorProfileActivationSink;
+
+    DWORD threadId;
+    struct list entry;
 } ThreadMgr;
 
 typedef struct tagEnumTfDocumentMgr {
@@ -110,6 +124,11 @@ typedef struct tagEnumTfDocumentMgr {
 
 static HRESULT EnumTfDocumentMgr_Constructor(struct list* head, IEnumTfDocumentMgrs **ppOut);
 
+static inline ThreadMgr *impl_from_ITfThreadMgr(ITfThreadMgr *iface)
+{
+    return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
+}
+
 static inline ThreadMgr *impl_from_ITfThreadMgrEx(ITfThreadMgrEx *iface)
 {
     return CONTAINING_RECORD(iface, ThreadMgr, ITfThreadMgrEx_iface);
@@ -155,6 +174,35 @@ static inline EnumTfDocumentMgr *impl_from_IEnumTfDocumentMgrs(IEnumTfDocumentMg
     return CONTAINING_RECORD(iface, EnumTfDocumentMgr, IEnumTfDocumentMgrs_iface);
 }
 
+/***********************************************************************
+ *              TF_GetThreadMgr (MSCTF.@)
+ */
+HRESULT WINAPI TF_GetThreadMgr(ITfThreadMgr **pptim)
+{
+    DWORD id = GetCurrentThreadId();
+    ThreadMgr *cursor;
+
+    TRACE("%p\n", pptim);
+
+    if (!pptim)
+        return E_INVALIDARG;
+
+    EnterCriticalSection(&ThreadMgrCs);
+    LIST_FOR_EACH_ENTRY(cursor, &ThreadMgrList, ThreadMgr, entry)
+    {
+        if (cursor->threadId == id)
+        {
+            ITfThreadMgrEx_AddRef(&cursor->ITfThreadMgrEx_iface);
+            *pptim = (ITfThreadMgr *)&cursor->ITfThreadMgrEx_iface;
+            LeaveCriticalSection(&ThreadMgrCs);
+            return S_OK;
+        }
+    }
+    LeaveCriticalSection(&ThreadMgrCs);
+    *pptim = NULL;
+    return E_FAIL;
+}
+
 static void ThreadMgr_Destructor(ThreadMgr *This)
 {
     struct list *cursor, *cursor2;
@@ -163,7 +211,9 @@ static void ThreadMgr_Destructor(ThreadMgr *This)
     if (This->focusHook)
         UnhookWindowsHookEx(This->focusHook);
 
-    TlsSetValue(tlsIndex,NULL);
+    EnterCriticalSection(&ThreadMgrCs);
+    list_remove(&This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
     TRACE("destroying %p\n", This);
     if (This->focus)
         ITfDocumentMgr_Release(This->focus);
@@ -386,17 +436,20 @@ static HRESULT WINAPI ThreadMgr_SetFocus(ITfThreadMgrEx *iface, ITfDocumentMgr *
 
 static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lParam)
 {
+    ITfThreadMgr *ThreadMgr_iface;
     ThreadMgr *This;
 
-    This = TlsGetValue(tlsIndex);
-    if (!This)
+    if (FAILED(TF_GetThreadMgr(&ThreadMgr_iface)))
     {
         ERR("Hook proc but no ThreadMgr for this thread. Serious Error\n");
         return 0;
     }
+
+    This = impl_from_ITfThreadMgr(ThreadMgr_iface);
     if (!This->focusHook)
     {
         ERR("Hook proc but no ThreadMgr focus Hook. Serious Error\n");
+        ITfThreadMgr_Release(ThreadMgr_iface);
         return 0;
     }
 
@@ -417,6 +470,7 @@ static LRESULT CALLBACK ThreadFocusHookProc(int nCode, WPARAM wParam, LPARAM lPa
         }
     }
 
+    ITfThreadMgr_Release(ThreadMgr_iface);
     return CallNextHookEx(This->focusHook, nCode, wParam, lParam);
 }
 
@@ -1338,13 +1392,8 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
         return CLASS_E_NOAGGREGATION;
 
     /* Only 1 ThreadMgr is created per thread */
-    This = TlsGetValue(tlsIndex);
-    if (This)
-    {
-        ThreadMgr_AddRef(&This->ITfThreadMgrEx_iface);
-        *ppOut = (IUnknown*)&This->ITfThreadMgrEx_iface;
+    if (SUCCEEDED(TF_GetThreadMgr((ITfThreadMgr **)ppOut)))
         return S_OK;
-    }
 
     This = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(ThreadMgr));
     if (This == NULL)
@@ -1359,7 +1408,6 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     This->ITfUIElementMgr_iface.lpVtbl = &ThreadMgrUIElementMgrVtbl;
     This->ITfSourceSingle_iface.lpVtbl = &SourceSingleVtbl;
     This->refCount = 1;
-    TlsSetValue(tlsIndex,This);
 
     CompartmentMgr_Constructor((IUnknown*)&This->ITfThreadMgrEx_iface, &IID_IUnknown, (IUnknown**)&This->CompartmentMgr);
 
@@ -1376,6 +1424,11 @@ HRESULT ThreadMgr_Constructor(IUnknown *pUnkOuter, IUnknown **ppOut)
     list_init(&This->UIElementSink);
     list_init(&This->InputProcessorProfileActivationSink);
 
+    This->threadId = GetCurrentThreadId();
+    EnterCriticalSection(&ThreadMgrCs);
+    list_add_tail(&ThreadMgrList, &This->entry);
+    LeaveCriticalSection(&ThreadMgrCs);
+
     TRACE("returning %p\n", This);
     *ppOut = (IUnknown *)&This->ITfThreadMgrEx_iface;
     return S_OK;
From ed04e35d3f7af02267fb4e21578b3ccb27703836 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Mon, 23 Sep 2019 13:29:16 -0500
Subject: [PATCH] dxdiag: Dump to stdout if no filename is given

---
 programs/dxdiag/main.c   |  8 +++++++-
 programs/dxdiag/output.c | 10 +++++++---
 2 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/programs/dxdiag/main.c b/programs/dxdiag/main.c
index 4533236f0f5..353e9f50fb9 100644
--- a/programs/dxdiag/main.c
+++ b/programs/dxdiag/main.c
@@ -71,7 +71,13 @@ static BOOL process_file_name(const WCHAR *cmdline, enum output_type output_type
         endptr = cmdline + lstrlenW(cmdline);
 
     len = endptr - cmdline;
-    if (len == 0 || len >= filename_len)
+    if (len == 0)
+    {
+        *filename = 0;
+        return TRUE;
+    }
+
+    if (len >= filename_len)
         return FALSE;
 
     memcpy(filename, cmdline, len * sizeof(WCHAR));
diff --git a/programs/dxdiag/output.c b/programs/dxdiag/output.c
index 50240fb2860..f0f6a6da0c3 100644
--- a/programs/dxdiag/output.c
+++ b/programs/dxdiag/output.c
@@ -169,8 +169,12 @@ static BOOL output_text_information(struct dxdiag_information *dxdiag_info, cons
 
     fill_system_text_output_table(dxdiag_info, output_table[0].fields);
 
-    hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
-                        NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (filename && *filename)
+        hFile = CreateFileW(filename, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
+                            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
+    else
+        hFile = GetStdHandle(STD_OUTPUT_HANDLE);
+
     if (hFile == INVALID_HANDLE_VALUE)
     {
         WINE_ERR("File creation failed, last error %u\n", GetLastError());
@@ -227,7 +231,7 @@ static HRESULT save_xml_document(IXMLDOMDocument *xmldoc, const WCHAR *filename)
     VARIANT destVar;
     HRESULT hr;
 
-    if (!bstr)
+    if (!bstr || !filename || !*filename)
         return E_OUTOFMEMORY;
 
     V_VT(&destVar) = VT_BSTR;
From 5cd65deffffad9073538acf4fd8e794ac07824a5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 9 Oct 2019 09:47:12 +0200
Subject: [PATCH] makedep: Align PE sections so they can be directly mmaped.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This should help linux perf tool match the binary files on disk with the
code regions in memory.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---
 tools/makedep.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/tools/makedep.c b/tools/makedep.c
index 6079d1fe28b..18e7b8a913e 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -3245,6 +3245,7 @@ static void output_module( struct makefile *make )
     output_filenames_obj_dir( make, make->res_files );
     output_filenames( all_libs );
     output_filename( make->is_cross ? "$(CROSSLDFLAGS)" : "$(LDFLAGS)" );
+    output_filename( make->is_cross ? "-Wl,--file-alignment,4096" : "" );
     output( "\n" );
 
     if (spec_file && make->importlib)
From 213905a322620eb326b655ab89fbca07316e6357 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Tue, 19 Nov 2019 09:59:17 -0600
Subject: [PATCH] HACK: dxgi: Return empty GPU string for Crazy Machines 3

If the GPU string is long enough, the game will crash trying to
dereference part of it. Probably this is due to missing Media Foundation
support. Try to remove this hack after the game's videos successfully
play back.
---
 dlls/dxgi/adapter.c | 20 ++++++++++++++++++++
 1 file changed, 20 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index d2fc629c843..5a97590dbce 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -161,12 +161,32 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     if (FAILED(hr = wined3d_get_adapter_identifier(adapter->factory->wined3d, adapter->ordinal, 0, &adapter_id)))
         return hr;
 
+    {
+        /* HACK for Proton issue #3204
+         *
+         * Due to reading uninitialized memory, the game tries to dereference
+         * part of the GPU Description string if it is long enough. So return
+         * an empty string instead.
+         *
+         * See the bug report for the full description, but we may be able to
+         * remove this hack after implementing enough of Media Foundation for
+         * this game's videos to play back.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "351920"))
+        {
+            desc->Description[0] = 0;
+            goto skip_description;
+        }
+    }
+
     if (!MultiByteToWideChar(CP_ACP, 0, description, -1, desc->Description, ARRAY_SIZE(description)))
     {
         DWORD err = GetLastError();
         ERR("Failed to translate description %s (%#x).\n", debugstr_a(description), err);
         hr = E_FAIL;
     }
+skip_description:
 
     desc->VendorId = adapter_id.vendor_id;
     desc->DeviceId = adapter_id.device_id;
From 4aa052e0c8ae276fc07afcd93d6e290a88214837 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 15 Jan 2020 10:17:23 -0600
Subject: [PATCH] dsound: Initialize primary buffer with device's channel
 layout

Fixes surround sound in some games, like Borderlands GOTY and Dead
Space.
---
 dlls/dsound/dsound.c         | 77 +-----------------------------------
 dlls/dsound/dsound_private.h |  1 -
 dlls/dsound/primary.c        | 75 ++++++++++++++++++++++++++++++++++-
 3 files changed, 76 insertions(+), 77 deletions(-)

diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index 8e2b839fe89..630d8c7e16a 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -23,7 +23,6 @@
 #include <assert.h>
 #include <stdarg.h>
 #include <stdio.h>
-#include <math.h>
 
 #define COBJMACROS
 
@@ -138,9 +137,9 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
     device->ref            = 1;
     device->priolevel      = DSSCL_NORMAL;
     device->stopped        = 1;
-    device->speaker_config = DSSPEAKER_COMBINED(DSSPEAKER_STEREO, DSSPEAKER_GEOMETRY_WIDE);
 
-    DSOUND_ParseSpeakerConfig(device);
+    device->speaker_config = 0;
+    device->num_speakers = 0;
 
     /* 3D listener initial parameters */
     device->ds3dl.dwSize   = sizeof(DS3DLISTENER);
@@ -1127,75 +1126,3 @@ HRESULT WINAPI DirectSoundCreate8(
 
     return hr;
 }
-
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
-{
-    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
-        case DSSPEAKER_MONO:
-            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
-            device->speaker_num[0] = 0;
-            device->num_speakers = 1;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_STEREO:
-        case DSSPEAKER_HEADPHONE:
-            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
-            device->speaker_num[0] = 0; /* Left */
-            device->speaker_num[1] = 1; /* Right */
-            device->num_speakers = 2;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_QUAD:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
-            device->speaker_num[0] = 2; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 1; /* Front right */
-            device->speaker_num[3] = 3; /* Rear right */
-            device->num_speakers = 4;
-            device->lfe_channel = -1;
-        break;
-
-        case DSSPEAKER_5POINT1_BACK:
-            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
-            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        case DSSPEAKER_5POINT1_SURROUND:
-            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
-            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
-            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
-            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
-            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
-            device->speaker_angles[5] = 9999.0f;
-            device->speaker_num[0] = 4; /* Rear left */
-            device->speaker_num[1] = 0; /* Front left */
-            device->speaker_num[2] = 2; /* Front centre */
-            device->speaker_num[3] = 1; /* Front right */
-            device->speaker_num[4] = 5; /* Rear right */
-            device->speaker_num[5] = 3; /* LFE */
-            device->num_speakers = 6;
-            device->lfe_channel = 3;
-        break;
-
-        default:
-            WARN("unknown speaker_config %u\n", device->speaker_config);
-    }
-}
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 69c4a2f3902..1a3e88a0d29 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -202,7 +202,6 @@ HRESULT IKsPrivatePropertySetImpl_Create(REFIID riid, void **ppv) DECLSPEC_HIDDE
 HRESULT DSOUND_Create(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT DSOUND_Create8(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 HRESULT IDirectSoundImpl_Create(IUnknown *outer_unk, REFIID riid, void **ppv, BOOL has_ds8) DECLSPEC_HIDDEN;
-void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device) DECLSPEC_HIDDEN;
 
 /* primary.c */
 
diff --git a/dlls/dsound/primary.c b/dlls/dsound/primary.c
index 852ec51b7ff..fdbbc00cd33 100644
--- a/dlls/dsound/primary.c
+++ b/dlls/dsound/primary.c
@@ -24,6 +24,7 @@
  */
 
 #include <stdarg.h>
+#include <math.h>
 
 #define COBJMACROS
 #define NONAMELESSUNION
@@ -110,6 +111,78 @@ static DWORD DSOUND_FindSpeakerConfig(IMMDevice *mmdevice, int channels)
     return def;
 }
 
+static void DSOUND_ParseSpeakerConfig(DirectSoundDevice *device)
+{
+    switch (DSSPEAKER_CONFIG(device->speaker_config)) {
+        case DSSPEAKER_MONO:
+            device->speaker_angles[0] = M_PI/180.0f * 0.0f;
+            device->speaker_num[0] = 0;
+            device->num_speakers = 1;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_STEREO:
+        case DSSPEAKER_HEADPHONE:
+            device->speaker_angles[0] = M_PI/180.0f * -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  90.0f;
+            device->speaker_num[0] = 0; /* Left */
+            device->speaker_num[1] = 1; /* Right */
+            device->num_speakers = 2;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_QUAD:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[3] = M_PI/180.0f *  135.0f;
+            device->speaker_num[0] = 2; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 1; /* Front right */
+            device->speaker_num[3] = 3; /* Rear right */
+            device->num_speakers = 4;
+            device->lfe_channel = -1;
+        break;
+
+        case DSSPEAKER_5POINT1_BACK:
+            device->speaker_angles[0] = M_PI/180.0f * -135.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -45.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   45.0f;
+            device->speaker_angles[4] = M_PI/180.0f *  135.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        case DSSPEAKER_5POINT1_SURROUND:
+            device->speaker_angles[0] = M_PI/180.0f *  -90.0f;
+            device->speaker_angles[1] = M_PI/180.0f *  -30.0f;
+            device->speaker_angles[2] = M_PI/180.0f *    0.0f;
+            device->speaker_angles[3] = M_PI/180.0f *   30.0f;
+            device->speaker_angles[4] = M_PI/180.0f *   90.0f;
+            device->speaker_angles[5] = 9999.0f;
+            device->speaker_num[0] = 4; /* Rear left */
+            device->speaker_num[1] = 0; /* Front left */
+            device->speaker_num[2] = 2; /* Front centre */
+            device->speaker_num[3] = 1; /* Front right */
+            device->speaker_num[4] = 5; /* Rear right */
+            device->speaker_num[5] = 3; /* LFE */
+            device->num_speakers = 6;
+            device->lfe_channel = 3;
+        break;
+
+        default:
+            WARN("unknown speaker_config %u\n", device->speaker_config);
+    }
+}
+
 static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client,
 				 BOOL forcewave, WAVEFORMATEX **wfx)
 {
@@ -124,7 +197,7 @@ static HRESULT DSOUND_WaveFormat(DirectSoundDevice *device, IAudioClient *client
         if (FAILED(hr))
             return hr;
 
-        if (mixwfe->Format.nChannels < device->num_speakers) {
+        if (device->num_speakers == 0 || mixwfe->Format.nChannels < device->num_speakers) {
             device->speaker_config = DSOUND_FindSpeakerConfig(device->mmdevice, mixwfe->Format.nChannels);
             DSOUND_ParseSpeakerConfig(device);
         } else if (mixwfe->Format.nChannels > device->num_speakers) {
From 749bf5fcd5f41a39301428a7fccd1e4febcd6f90 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:28 +0200
Subject: [PATCH] dwmapi: Improve DwmGetWindowAttribute stub.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/dwmapi_main.c | 26 ++++++++++++++++++++++++--
 1 file changed, 24 insertions(+), 2 deletions(-)

diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index 6378a091f0b..e976fda77f2 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -205,9 +205,31 @@ BOOL WINAPI DwmDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam,
  */
 HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attribute, DWORD size)
 {
-    FIXME("(%p %d %p %d) stub\n", hwnd, attribute, pv_attribute, size);
+    if (!hwnd) return E_HANDLE;
+    if (!pv_attribute) return E_INVALIDARG;
 
-    return E_NOTIMPL;
+    switch (attribute)
+    {
+    case DWMWA_NCRENDERING_ENABLED:
+        if (size < sizeof(BOOL)) return E_INVALIDARG;
+
+        WARN("DWMWA_NCRENDERING_ENABLED: always returning FALSE.\n");
+        *(BOOL*)(pv_attribute) = FALSE;
+        break;
+
+    case DWMWA_CLOAKED:
+        if (size < sizeof(DWORD)) return E_INVALIDARG;
+
+        WARN("DWMWA_CLOAKED: always returning 0.\n");
+        *(DWORD*)(pv_attribute) = 0;
+        break;
+
+    default:
+        FIXME("unimplemented attribute %d, size %u, for hwnd %p.\n", attribute, size, hwnd);
+        return E_INVALIDARG;
+    }
+
+    return S_OK;
 }
 
 /**********************************************************************
From 1a2e600a9c35a9558b32e7986668d7dc81c8b5ae Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Gabriel=20Iv=C4=83ncescu?= <gabrielopcode@gmail.com>
Date: Fri, 13 Dec 2019 15:54:30 +0200
Subject: [PATCH] dwmapi: Add partial implementation of
 DWMWA_EXTENDED_FRAME_BOUNDS.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Gabriel Ivăncescu <gabrielopcode@gmail.com>
---
 dlls/dwmapi/Makefile.in    |  1 +
 dlls/dwmapi/dwmapi_main.c  |  7 +++++++
 dlls/dwmapi/tests/dwmapi.c | 14 ++++++++++++++
 3 files changed, 22 insertions(+)

diff --git a/dlls/dwmapi/Makefile.in b/dlls/dwmapi/Makefile.in
index 3a3691326f8..d273a22c8f3 100644
--- a/dlls/dwmapi/Makefile.in
+++ b/dlls/dwmapi/Makefile.in
@@ -1,5 +1,6 @@
 MODULE    = dwmapi.dll
 IMPORTLIB = dwmapi
+IMPORTS   = user32
 
 EXTRADLLFLAGS = -mno-cygwin
 
diff --git a/dlls/dwmapi/dwmapi_main.c b/dlls/dwmapi/dwmapi_main.c
index e976fda77f2..212c88c5a02 100644
--- a/dlls/dwmapi/dwmapi_main.c
+++ b/dlls/dwmapi/dwmapi_main.c
@@ -217,6 +217,13 @@ HRESULT WINAPI DwmGetWindowAttribute(HWND hwnd, DWORD attribute, PVOID pv_attrib
         *(BOOL*)(pv_attribute) = FALSE;
         break;
 
+    case DWMWA_EXTENDED_FRAME_BOUNDS:
+        if (size < sizeof(RECT)) return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
+
+        WARN("DWMWA_EXTENDED_FRAME_BOUNDS: returning window rect.\n");
+        GetWindowRect(hwnd, pv_attribute);
+        break;
+
     case DWMWA_CLOAKED:
         if (size < sizeof(DWORD)) return E_INVALIDARG;
 
From c099ae745b3a63edee1677a2da01cab5aa5b8562 Mon Sep 17 00:00:00 2001
From: Zebediah Figura <z.figura12@gmail.com>
Date: Tue, 28 Jan 2020 14:30:43 -0600
Subject: [PATCH] winegstreamer: HACK: Try harder to register winegstreamer
 filters.

The IDL declarations should actually be unnecessary with the quartz part, but there's a chance that an application will try to create filters before it creates the graph.
---
 dlls/quartz/filtergraph.c     | 17 +++++++++++++++++
 dlls/winegstreamer/winegstreamer_classes.idl | 21 +++++++++++++++++++++
 2 files changed, 38 insertions(+)

diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index 1ed41bdcec5..0af6e1ded5f 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -5681,11 +5681,28 @@ static const IUnknownVtbl IInner_VTable =
     FilterGraphInner_Release
 };
 
+static BOOL CALLBACK register_winegstreamer_proc(INIT_ONCE *once, void *param, void **ctx)
+{
+    HMODULE mod = LoadLibraryW(L"winegstreamer.dll");
+    if (mod)
+    {
+        HRESULT (WINAPI *proc)(void) = (void *)GetProcAddress(mod, "DllRegisterServer");
+        proc();
+        FreeLibrary(mod);
+    }
+    return TRUE;
+}
+
 static HRESULT filter_graph_common_create(IUnknown *outer, IUnknown **out, BOOL threaded)
 {
+    static INIT_ONCE once = INIT_ONCE_STATIC_INIT;
     struct filter_graph *object;
     HRESULT hr;
 
+    /* HACK: our build system makes it difficult to load gstreamer on prefix
+     * creation, so it won't get registered. Do that here instead. */
+    InitOnceExecuteOnce(&once, register_winegstreamer_proc, NULL, NULL);
+
     *out = NULL;
 
     fimpl = CoTaskMemAlloc(sizeof(*fimpl));
From aa6ab7464758508b3348b3ce390c1524c9ce32a2 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 30 Jan 2020 10:16:19 -0600
Subject: [PATCH] winegstreamer: HACK: Use a different gst registry file per
 architecture

---
 dlls/winegstreamer/main.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 379f54ab4ec..0fb6b0b5ad3 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -421,9 +421,25 @@ static BOOL CALLBACK init_gstreamer_proc(INIT_ONCE *once, void *param, void **ct
     char **argv = args;
     int argc = 2;
     GError *err = NULL;
+    const char *e;
 
     TRACE("Initializing...\n");
 
+    if ((e = getenv("WINE_GST_REGISTRY_DIR")))
+    {
+        char gst_reg[PATH_MAX];
+#if defined(__x86_64__)
+        const char *arch = "/registry.x86_64.bin";
+#elif defined(__i386__)
+        const char *arch = "/registry.i386.bin";
+#else
+#error Bad arch
+#endif
+        strcpy(gst_reg, e);
+        strcat(gst_reg, arch);
+        setenv("GST_REGISTRY_1_0", gst_reg, 1);
+    }
+
     argv[0] = argv0;
     argv[1] = argv1;
     argv[2] = NULL;
From 52c36274080a6edc1f1420b08df1ecf0defa9ca3 Mon Sep 17 00:00:00 2001
From: Derek Lesho <dlesho@codeweavers.com>
Date: Thu, 5 Dec 2019 12:41:57 -0600
Subject: [PATCH] bcrypt: Fallback to _gnutls_decode_ber_rs_raw if
 gnutls_decode_rs_value is unavailable.

This can be removed when the runtime ships gnutls >= 3.6
---
 dlls/bcrypt/gnutls.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index 868f898bbbb..95f498123ea 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -267,8 +267,11 @@ BOOL gnutls_initialize(void)
     }
     if (!(pgnutls_decode_rs_value = dlsym( libgnutls_handle, "gnutls_decode_rs_value" )))
     {
-        WARN("gnutls_decode_rs_value not found\n");
-        pgnutls_decode_rs_value = compat_gnutls_decode_rs_value;
+        if (!(pgnutls_decode_rs_value = dlsym( libgnutls_handle, "_gnutls_decode_ber_rs_raw" )))
+        {
+            WARN("gnutls_decode_rs_value and legacy alternative _gnutls_decode_ber_rs_raw not found\n");
+            pgnutls_decode_rs_value = compat_gnutls_decode_rs_value;
+        }
     }
 
     if (TRACE_ON( bcrypt ))
From 8fd9d6bd3d567893f933b7d55615446476745654 Mon Sep 17 00:00:00 2001
From: Vincent Povirk <vincent@codeweavers.com>
Date: Wed, 1 Apr 2020 11:47:05 -0500
Subject: [PATCH] winebrowser: Restore original LD_LIBRARY_PATH before calling
 to system

---
 programs/winebrowser/main.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/programs/winebrowser/main.c b/programs/winebrowser/main.c
index 9cd6812d032..9e5fe2f3129 100644
--- a/programs/winebrowser/main.c
+++ b/programs/winebrowser/main.c
@@ -69,6 +69,17 @@ static char *strdup_unixcp( const WCHAR *str )
     return ret;
 }
 
+static void restore_system_environment(void)
+{
+    const char* orig_ld_path = getenv("ORIG_LD_LIBRARY_PATH");
+
+    if (orig_ld_path)
+    {
+        setenv("LD_LIBRARY_PATH", orig_ld_path, 1);
+        unsetenv("ORIG_LD_LIBRARY_PATH");
+    }
+}
+
 /* try to launch a unix app from a comma separated string of app names */
 static int launch_app( const WCHAR *candidates, const WCHAR *argv1 )
 {
@@ -78,6 +89,11 @@ static int launch_app( const WCHAR *candidates, const WCHAR *argv1 )
 
     if (!(cmdline = strdup_unixcp( argv1 ))) return 1;
 
+    /* PROTON HACK: Restore ORIG_LD_LIBRARY_PATH to LD_LIBRARY_PATH.
+     * System programs may not work correctly with our libraries, in
+     * particular gio on Ubuntu 19.04 is broken by our libgio. */
+    restore_system_environment();
+
     while (*candidates)
     {
         WCHAR **args = CommandLineToArgvW( candidates, &count );
From b739d48093cce805b7b4f48fdbd9d0bb62bc8013 Mon Sep 17 00:00:00 2001
From: Brendan Shanks <bshanks@codeweavers.com>
Date: Mon, 13 Apr 2020 16:25:47 -0700
Subject: [PATCH] HACK: dxgi: Swap around memory sizes for GTA IV

GTA IV ends up using its "Intel integrated" codepath for determining
VRAM size (since nvapi/atiadlxx fail), but this requires that
DedicatedVideoMemory is a very small dummy value, and SharedSystemMemory
is the actual VRAM size.
Swap the memory values around so this works.
---
 dlls/dxgi/adapter.c | 19 +++++++++++++++++++
 1 file changed, 19 insertions(+)

diff --git a/dlls/dxgi/adapter.c b/dlls/dxgi/adapter.c
index 5a97590dbce..a5563498cdd 100644
--- a/dlls/dxgi/adapter.c
+++ b/dlls/dxgi/adapter.c
@@ -200,6 +200,25 @@ static HRESULT dxgi_adapter_get_desc(struct dxgi_adapter *adapter, DXGI_ADAPTER_
     desc->GraphicsPreemptionGranularity = 0; /* FIXME */
     desc->ComputePreemptionGranularity = 0; /* FIXME */
 
+    {
+        /* HACK
+         *
+         * Grand Theft Auto IV first tries to get VRAM size using nvapi/atiadlxx,
+         * after that fails it falls back to the Intel integrated codepath which
+         * uses DXGI.
+         *
+         * DedicatedVideoMemory must be a dummy value less than 200 MB, then
+         * SharedSystemMemory will be used as the VRAM size.
+         * In case of failure, the game will just use 512 MB as VRAM size.
+         */
+        const char *sgi = getenv("SteamGameId");
+        if(sgi && !strcmp(sgi, "12210"))
+        {
+            desc->SharedSystemMemory = adapter_id.video_memory;
+            desc->DedicatedVideoMemory = 32 * 1024 * 1024;
+        }
+    }
+
     return hr;
 }
 
From c619409f235cf660cdd4fd3295d5e04ec628daa1 Mon Sep 17 00:00:00 2001
From: Alexey Prokhin <alexey@prokhin.ru>
Date: Thu, 23 Apr 2020 12:29:55 +0300
Subject: [PATCH] kernelbase: Set the proper error code in
 GetQueuedCompletionStatus{Ex} when the handle is closed.

Planet Zoo relies on it being ERROR_ABANDONED_WAIT_0.
---
 dlls/kernelbase/sync.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/dlls/kernelbase/sync.c b/dlls/kernelbase/sync.c
index 0ae3aadde92..e95ede8aed5 100644
--- a/dlls/kernelbase/sync.c
+++ b/dlls/kernelbase/sync.c
@@ -960,6 +960,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatus( HANDLE port, LPDWORD co
     }
 
     if (status == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
+    else if (status == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
@@ -981,6 +982,7 @@ BOOL WINAPI DECLSPEC_HOTPATCH GetQueuedCompletionStatusEx( HANDLE port, OVERLAPP
     if (ret == STATUS_SUCCESS) return TRUE;
     else if (ret == STATUS_TIMEOUT) SetLastError( WAIT_TIMEOUT );
     else if (ret == STATUS_USER_APC) SetLastError( WAIT_IO_COMPLETION );
+    else if (ret == ERROR_WAIT_NO_CHILDREN) SetLastError( ERROR_ABANDONED_WAIT_0 );
     else SetLastError( RtlNtStatusToDosError(ret) );
     return FALSE;
 }

From fdc1acce7e81f08eb10652b7b39b3d3e4bbed8f8 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 24 Apr 2020 20:08:38 +0300
Subject: [PATCH] Avoid undefined result in ntdll_wcstoumbs() in case of error.

Undefined result is due to RtlUnicodeToUTF8N() not setting output
length on error which is a correct behaviour according to
existing tests.

'Planet Zoo' is affected which passes NULL object name buffer to
NtCreateFile().

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/ntdll/locale.c | 2 +-
 1 file changed, 1 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/locale.c b/dlls/ntdll/locale.c
index d6bde700e42..4f03e3881f0 100644
--- a/dlls/ntdll/locale.c
+++ b/dlls/ntdll/locale.c
@@ -769,7 +769,7 @@ DWORD ntdll_umbstowcs( const char *src, DWORD srclen, WCHAR *dst, DWORD dstlen )
  */
 int ntdll_wcstoumbs( const WCHAR *src, DWORD srclen, char *dst, DWORD dstlen, BOOL strict )
 {
-    DWORD i, reslen;
+    DWORD i, reslen = 0;
 
     if (!unix_table.CodePage)
         RtlUnicodeToUTF8N( dst, dstlen, &reslen, src, srclen * sizeof(WCHAR) );

From 0255dbc3afd3ff673fa701e7802474483252fcb2 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 13 Jul 2020 10:21:49 -0500
Subject: [PATCH] ntdll: Handle NULL object name buffer in
 nt_to_unix_file_name_attr().

---
 dlls/ntdll/tests/file.c | 22 +++++++++++++++++++++-
 dlls/ntdll/unix/file.c  |  8 ++++++++
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
index 6164b0c4bde..031be95e233 100644
--- a/dlls/ntdll/tests/file.c
+++ b/dlls/ntdll/tests/file.c
@@ -144,16 +144,36 @@ static void create_file_test(void)
     static const char testdata[] = "Hello World";
     static const WCHAR sepW[] = {'\\',0};
     FILE_NETWORK_OPEN_INFORMATION info;
+    UNICODE_STRING nameW, null_string;
     NTSTATUS status;
     HANDLE dir, file;
     WCHAR path[MAX_PATH], temp[MAX_PATH];
     OBJECT_ATTRIBUTES attr;
     IO_STATUS_BLOCK io;
-    UNICODE_STRING nameW;
     LARGE_INTEGER offset;
     char buf[32];
     DWORD ret;
 
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = NULL;
+    attr.ObjectName = &null_string;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    null_string.Buffer = NULL;
+    null_string.Length = 256;
+
+    /* try various open modes and options on directories */
+    status = pNtCreateFile( &dir, GENERIC_READ|GENERIC_WRITE, &attr, &io, NULL, 0,
+                            FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, FILE_DIRECTORY_FILE, NULL, 0 );
+    ok( status == STATUS_ACCESS_VIOLATION, "Got unexpected status %#x.\n",  status );
+
+    null_string.Length = 0;
+    status = pNtCreateFile( &dir, GENERIC_READ|GENERIC_WRITE, &attr, &io, NULL, 0,
+                            FILE_SHARE_READ|FILE_SHARE_WRITE, FILE_OPEN, FILE_DIRECTORY_FILE, NULL, 0 );
+    ok( status == STATUS_OBJECT_PATH_SYNTAX_BAD, "Got unexpected status %#x.\n",  status );
+
     GetCurrentDirectoryW( MAX_PATH, path );
     pRtlDosPathNameToNtPathName_U( path, &nameW, NULL, NULL );
     attr.Length = sizeof(attr);
diff --git a/dlls/ntdll/unix/file.c b/dlls/ntdll/unix/file.c
index 20eb6a05922..d99c6b462b2 100644
--- a/dlls/ntdll/unix/file.c
+++ b/dlls/ntdll/unix/file.c
@@ -3185,8 +3185,16 @@ static NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, char *
     int name_len, unix_len;
     NTSTATUS status;
 
+    if (!attr->ObjectName->Buffer && attr->ObjectName->Length)
+        return STATUS_ACCESS_VIOLATION;
+
     if (!attr->RootDirectory)  /* without root dir fall back to normal lookup */
+    {
+        if (!attr->ObjectName->Buffer)
+            return STATUS_OBJECT_PATH_SYNTAX_BAD;
+
         return nt_to_unix_file_name( attr->ObjectName, name_ret, disposition );
+    }
 
     name     = attr->ObjectName->Buffer;
     name_len = attr->ObjectName->Length / sizeof(WCHAR);
From 514d3e11c999b11a95ab35df5b4ab454d34fe791 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 13 May 2020 13:55:55 +0300
Subject: [PATCH] ntdll: Add WINE_DISABLE_WRITE_WATCH env var to disable write
 watch support.

Massively improves performance for corert games (Streets of Rage 4).
Could be fixed properly with Linux kernel changes.
---
 dlls/ntdll/unix/virtual.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/dlls/ntdll/unix/virtual.c b/dlls/ntdll/unix/virtual.c
index 7ea80852090..272e1c5b176 100644
--- a/dlls/ntdll/unix/virtual.c
+++ b/dlls/ntdll/unix/virtual.c
@@ -3425,6 +3425,22 @@ NTSTATUS WINAPI NtAllocateVirtualMemory( HANDLE process, PVOID *ret, ULONG_PTR z
     if (zero_bits > 21 && zero_bits < 32) return STATUS_INVALID_PARAMETER_3;
     if (!is_win64 && !is_wow64 && zero_bits >= 32) return STATUS_INVALID_PARAMETER_3;
 
+    if (type & MEM_WRITE_WATCH)
+    {
+        static int disable = -1;
+
+        if (disable == -1)
+        {
+            const char *env_var;
+
+            if ((disable = (env_var = getenv("WINE_DISABLE_WRITE_WATCH")) && atoi(env_var)))
+                FIXME("Disabling write watch support.\n");
+        }
+
+        if (disable)
+            return STATUS_NOT_SUPPORTED;
+    }
+
     if (process != NtCurrentProcess())
     {
         apc_call_t call;
From 912701cb515acdc8e0ff263552f656cd49f60714 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 13:01:26 +0200
Subject: [PATCH] d3d10core: Implement D3D10CoreRegisterLayers.

---
 dlls/d3d10core/d3d10core_main.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/d3d10core/d3d10core_main.c b/dlls/d3d10core/d3d10core_main.c
index d364be90d6d..5a9a4a211c1 100644
--- a/dlls/d3d10core/d3d10core_main.c
+++ b/dlls/d3d10core/d3d10core_main.c
@@ -29,11 +29,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d10core);
 HRESULT WINAPI D3D11CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter, unsigned int flags,
         const D3D_FEATURE_LEVEL *feature_levels, unsigned int level_count, ID3D11Device **device);
 
+HRESULT WINAPI D3D11CoreRegisterLayers(void);
+
 HRESULT WINAPI D3D10CoreRegisterLayers(void)
 {
     TRACE("\n");
 
-    return E_NOTIMPL;
+    return D3D11CoreRegisterLayers();
 }
 
 HRESULT WINAPI D3D10CoreCreateDevice(IDXGIFactory *factory, IDXGIAdapter *adapter,

From 376a037ce1391e071835a0bf30ebf1fcec43c367 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 15 May 2020 12:59:44 +0200
Subject: [PATCH] dxgi: Add fallback to D3D10CoreRegisterLayers.

If D3D11CoreRegisterLayers is not found in module.
---
 dlls/dxgi/dxgi_main.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/dlls/dxgi/dxgi_main.c b/dlls/dxgi/dxgi_main.c
index 83c3f3734a7..006ab370844 100644
--- a/dlls/dxgi/dxgi_main.c
+++ b/dlls/dxgi/dxgi_main.c
@@ -106,8 +106,8 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)
 
     if (!dxgi_main.d3d10core)
     {
-        HRESULT hr;
-        HRESULT (WINAPI *d3d11core_register_layers)(void);
+        HRESULT hr = E_FAIL;
+        HRESULT (WINAPI *register_layers)(void);
         HMODULE mod;
         BOOL ret;
 
@@ -117,8 +117,10 @@ static HRESULT register_d3d10core_layers(HMODULE d3d10core)
             return E_FAIL;
         }
 
-        d3d11core_register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers");
-        hr = d3d11core_register_layers();
+        if ((register_layers = (void *)GetProcAddress(mod, "D3D11CoreRegisterLayers")) ||
+            (register_layers = (void *)GetProcAddress(mod, "D3D10CoreRegisterLayers")))
+            hr = register_layers();
+
         if (FAILED(hr))
         {
             ERR("Failed to register d3d11 layers, returning %#x.\n", hr);

From 5b00ca69a1927e1d0df4cf26160228e460568c51 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 9 Jun 2020 14:16:22 +0300
Subject: [PATCH] kernelbase: HACK Add an option to blacklist files.

---
 dlls/kernelbase/file.c | 76 +++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 75 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index eb2ef57c7d6..c7881fe4516 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -41,6 +41,8 @@
 #include "wine/exception.h"
 #include "wine/debug.h"
 
+#include "wine/heap.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 
 /* info structure for FindFirstFile handle */
@@ -432,6 +434,72 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileA( LPCSTR name, DWORD access, DWORD sh
     return CreateFileW( nameW, access, sharing, sa, creation, attributes, template );
 }
 
+#define MAX_BLACKLISTED_FILENAMES 32
+
+static struct
+{
+    const WCHAR *name;
+    size_t name_len;
+}
+blacklist_filenames[MAX_BLACKLISTED_FILENAMES];
+
+static unsigned int blacklist_filename_count;
+
+static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
+{
+    const WCHAR separators[] = L",; ";
+    WCHAR *buffer, *token;
+    DWORD size;
+
+    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
+        return TRUE;
+
+    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    {
+        ERR("No memory.\n");
+        return FALSE;
+    }
+
+    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+    {
+        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+        return FALSE;
+    }
+
+    blacklist_filename_count = 0;
+    token = wcstok(buffer, separators);
+    while (token && blacklist_filename_count < MAX_BLACKLISTED_FILENAMES)
+    {
+        FIXME("Blacklisting %s file.\n", debugstr_w(token));
+        blacklist_filenames[blacklist_filename_count].name = token;
+        blacklist_filenames[blacklist_filename_count++].name_len = wcslen(token);
+        token = wcstok(NULL, separators);
+    }
+
+    if (token && blacklist_filename_count == MAX_BLACKLISTED_FILENAMES)
+        ERR("File black list is too long.\n");
+
+    return TRUE;
+}
+
+static BOOL is_file_blacklisted(LPCWSTR filename)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    unsigned int i;
+    size_t len;
+
+    if (!InitOnceExecuteOnce(&init_once, init_file_blacklist, NULL, NULL))
+        return FALSE;
+
+    len = wcslen(filename);
+
+    for (i = 0; i < blacklist_filename_count; ++i)
+        if (blacklist_filenames[i].name_len <= len
+                && !wcsicmp(blacklist_filenames[i].name, filename + len - blacklist_filenames[i].name_len))
+            return TRUE;
+
+    return FALSE;
+}
 
 /*************************************************************************
  *	CreateFileW   (kernelbase.@)
@@ -460,7 +528,6 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
         FILE_OVERWRITE      /* TRUNCATE_EXISTING */
     };
 
-
     /* sanity checks */
 
     if (!filename || !filename[0])
@@ -479,6 +546,13 @@ HANDLE WINAPI DECLSPEC_HOTPATCH CreateFileW( LPCWSTR filename, DWORD access, DWO
            (sharing & FILE_SHARE_DELETE) ? "FILE_SHARE_DELETE " : "",
            creation, attributes);
 
+    if (is_file_blacklisted(filename))
+    {
+        FIXME("\"%s\" is blacklisted.\n", debugstr_w(filename));
+        SetLastError( ERROR_FILE_NOT_FOUND );
+        return INVALID_HANDLE_VALUE;
+    }
+
     if ((GetVersion() & 0x80000000) && !wcsncmp( filename, L"\\\\.\\", 4 ) &&
         !RtlIsDosDeviceName_U( filename + 4 ) &&
         wcsnicmp( filename + 4, L"PIPE\\", 5 ) &&

From 2409bd1f74be116172688a25df725290637c255a Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Wed, 10 Jun 2020 16:18:29 -0500
Subject: [PATCH] kernelbase: Apply blacklist automatically to Origin
 executables

---
 dlls/kernelbase/file.c | 54 ++++++++++++++++++++++++++++++++++--------
 1 file changed, 44 insertions(+), 10 deletions(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index c7881fe4516..bb4be45da5d 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -447,23 +447,57 @@ static unsigned int blacklist_filename_count;
 
 static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter, PVOID *context)
 {
+    static WCHAR origin_blacklist[] = L"kernel32.dll;user32.dll";
+
     const WCHAR separators[] = L",; ";
     WCHAR *buffer, *token;
     DWORD size;
 
-    if (!(size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
-        return TRUE;
-
-    if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+    if ((size = GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", NULL, 0)))
     {
-        ERR("No memory.\n");
-        return FALSE;
-    }
+        if (!(buffer = heap_alloc(sizeof(*buffer) * size)))
+        {
+            ERR("No memory.\n");
+            return FALSE;
+        }
 
-    if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        if (GetEnvironmentVariableW(L"WINE_BLACKLIST_FILES", buffer, size) != size - 1)
+        {
+            ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
+            return FALSE;
+        }
+    }
+    else
     {
-        ERR("Error getting WINE_BLACKLIST_FILES env variable.\n");
-        return FALSE;
+        static const WCHAR *origin_names[] = {
+            L"igoproxy64.exe",
+            L"igoproxy.exe",
+            L"origin.exe",
+            L"easteamproxy.exe"
+        };
+
+        WCHAR cur_exe[MAX_PATH];
+        DWORD cur_exe_len, i;
+
+        if (!(cur_exe_len = GetModuleFileNameW(NULL, cur_exe, ARRAY_SIZE(cur_exe))))
+            return TRUE;
+
+        buffer = NULL;
+
+        for (i = 0; i < ARRAY_SIZE(origin_names); ++i)
+        {
+            DWORD origin_name_len = wcslen(origin_names[i]);
+            if (cur_exe_len >= origin_name_len &&
+                    wcsicmp(cur_exe + cur_exe_len - origin_name_len, origin_names[i]) == 0)
+            {
+                FIXME("using origin file blacklist for %s\n", debugstr_w(cur_exe));
+                buffer = origin_blacklist;
+                break;
+            }
+        }
+
+        if (!buffer)
+            return TRUE;
     }
 
     blacklist_filename_count = 0;
From 027ff0c658ac00a7b5c1df014043265c83e74dbc Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 18 Dec 2019 13:49:00 +0100
Subject: [PATCH] HACK: user32: Strip gameoverlayrenderer.so from LD_PRELOAD
 before executing explorer.exe.

Work around a bug in gameoverlayrenderer which introduces 50ms hangs
during XCheckIfEvent after approx 40 minutes of gameplay.
---
 dlls/user32/win.c | 55 +++++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 55 insertions(+)

diff --git a/dlls/user32/cursoricon.c b/dlls/user32/cursoricon.c
index e772d541235..9d0cf716fd7 100644
--- a/dlls/user32/cursoricon.c
+++ b/dlls/user32/cursoricon.c
@@ -113,7 +113,7 @@ static int get_display_bpp(void)
 
 static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
 
-static const struct png_funcs *png_funcs;
+const struct png_funcs *png_funcs;
 
 static BOOL WINAPI load_libpng( INIT_ONCE *once, void *param, void **context )
 {
@@ -121,7 +121,7 @@ static BOOL WINAPI load_libpng( INIT_ONCE *once, void *param, void **context )
     return TRUE;
 }
 
-static BOOL have_libpng(void)
+BOOL have_libpng(void)
 {
     return InitOnceExecuteOnce( &init_once, load_libpng, NULL, NULL ) && png_funcs;
 }
diff --git a/dlls/user32/png.c b/dlls/user32/png.c
index a994c6de5c2..3054fd901a8 100644
--- a/dlls/user32/png.c
+++ b/dlls/user32/png.c
@@ -293,10 +293,16 @@ static BITMAPINFO * CDECL load_png(const char *png_data, DWORD *size)
     return info;
 }
 
-static const struct png_funcs png_funcs =
+int CDECL hack_unix_setenv(const char *name, const char *value, int overwrite)
+{
+    return setenv(name, value, overwrite);
+}
+
+static const struct png_funcs png_funcs_unix =
 {
     get_png_info,
-    load_png
+    load_png,
+    hack_unix_setenv,
 };
 
 NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *ptr_in, void *ptr_out )
@@ -335,7 +341,7 @@ NTSTATUS CDECL __wine_init_unix_lib( HMODULE module, DWORD reason, const void *p
     LOAD_FUNCPTR(png_set_read_fn);
 #undef LOAD_FUNCPTR
 
-    *(const struct png_funcs **)ptr_out = &png_funcs;
+    *(const struct png_funcs **)ptr_out = &png_funcs_unix;
     return STATUS_SUCCESS;
 }
 
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 7761a1ceb4f..5e42027b3c7 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -373,8 +373,12 @@ struct png_funcs
 {
     BOOL (CDECL *get_png_info)(const void *png_data, DWORD size, int *width, int *height, int *bpp);
     BITMAPINFO * (CDECL *load_png)(const char *png_data, DWORD *size);
+    int (CDECL *hack_unix_setenv)(const char *name, const char *value, int overwrite);
 };
 
+extern BOOL have_libpng(void);
+extern const struct png_funcs *png_funcs;
+
 /* Mingw's assert() imports MessageBoxA and gets confused by user32 exporting it */
 #ifdef __MINGW32__
 #undef assert
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 680defc2071..0ced1a5cd91 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -45,6 +45,15 @@ static DWORD process_layout = ~0u;
 
 static struct list window_surfaces = LIST_INIT( window_surfaces );
 
+static CRITICAL_SECTION desktop_section;
+static CRITICAL_SECTION_DEBUG desktop_critsect_debug =
+{
+    0, 0, &desktop_section,
+    { &desktop_critsect_debug.ProcessLocksList, &desktop_critsect_debug.ProcessLocksList },
+      0, 0, { (DWORD_PTR)(__FILE__ ": desktop_section") }
+};
+static CRITICAL_SECTION desktop_section = { &desktop_critsect_debug, -1, 0, 0, 0, 0 };
+
 static CRITICAL_SECTION surfaces_section;
 static CRITICAL_SECTION_DEBUG critsect_debug =
 {
@@ -2088,6 +2097,7 @@ HWND WINAPI GetDesktopWindow(void)
         WCHAR app[MAX_PATH + ARRAY_SIZE( L"\\explorer.exe" )];
         WCHAR cmdline[MAX_PATH + ARRAY_SIZE( L"\\explorer.exe /desktop" )];
         WCHAR desktop[MAX_PATH];
+        char *ld_preload;
         void *redir;
 
         SERVER_START_REQ( set_user_object_info )
@@ -2120,6 +2130,49 @@ HWND WINAPI GetDesktopWindow(void)
         lstrcpyW( cmdline, app );
         lstrcatW( cmdline, L" /desktop" );
 
+        /* HACK: Unset LD_PRELOAD before executing explorer.exe to disable buggy gameoverlayrenderer.so
+        * It's not going to work through the CreateProcessW env parameter, as it will not be used for the loader execv.
+        */
+        if (have_libpng())
+        {
+            EnterCriticalSection( &desktop_section);
+
+            if ((ld_preload = getenv("LD_PRELOAD")))
+            {
+                static char const gorso[] = "gameoverlayrenderer.so";
+                static unsigned int gorso_len = ARRAY_SIZE(gorso) - 1;
+                char *env, *next, *tmp;
+
+                env = HeapAlloc(GetProcessHeap(), 0, strlen(ld_preload) + 1);
+                strcpy(env, ld_preload);
+
+                tmp = env;
+                do
+                {
+                    if (!(next = strchr(tmp, ':')))
+                        next = tmp + strlen(tmp);
+
+                    if (next - tmp >= gorso_len &&
+                        strncmp(next - gorso_len, gorso, gorso_len) == 0)
+                    {
+                        if (*next)
+                            memmove(tmp, next + 1, strlen(next));
+                        else
+                            *tmp = 0;
+                        next = tmp;
+                    }
+                    else
+                    {
+                        tmp = next + 1;
+                    }
+                }
+                while (*next);
+
+                png_funcs->hack_unix_setenv("LD_PRELOAD", env, 1);
+                HeapFree(GetProcessHeap(), 0, env);
+            }
+        }
+
         Wow64DisableWow64FsRedirection( &redir );
         if (CreateProcessW( app, cmdline, NULL, NULL, FALSE, DETACHED_PROCESS,
                             NULL, windir, &si, &pi ))
@@ -2132,6 +2185,14 @@ HWND WINAPI GetDesktopWindow(void)
         else WARN( "failed to start explorer, err %d\n", GetLastError() );
         Wow64RevertWow64FsRedirection( redir );
 
+        /* HACK: Restore the previous value, just in case */
+        if (have_libpng())
+        {
+            if (ld_preload) png_funcs->hack_unix_setenv("LD_PRELOAD", ld_preload, 1);
+
+            LeaveCriticalSection( &desktop_section );
+        }
+
         SERVER_START_REQ( get_desktop_window )
         {
             req->force = 1;
From ff790e8d99f2026af9b8569355fc1df5e6f0c639 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Sat, 5 Sep 2020 01:09:37 +0300
Subject: [PATCH] wbemprox: HACK: Make Bloons TD6 happy so it does not exit
 after getting string Wine from bios info.

---
 dlls/wbemprox/builtin.c | 22 +++++++++++-----------
 1 file changed, 11 insertions(+), 11 deletions(-)

diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 43268221936..f39d6f0cd7b 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -1181,7 +1181,7 @@ static WCHAR *get_bios_string( BYTE id, const char *buf, UINT len )
 static WCHAR *get_bios_manufacturer( const char *buf, UINT len )
 {
     WCHAR *ret = get_bios_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"The Wine Project" );
+    if (!ret) return heap_strdupW( L"The Proton Project" );
     return ret;
 }
 
@@ -1227,7 +1227,7 @@ static WCHAR *get_bios_releasedate( const char *buf, UINT len )
 static WCHAR *get_bios_smbiosbiosversion( const char *buf, UINT len )
 {
     WCHAR *ret = get_bios_string( 2, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }
 
@@ -1307,7 +1307,7 @@ static enum fill_status fill_bios( struct table *table, const struct expr *cond
     rec->smbiosminorversion     = get_bios_smbiosminorversion( buf, len );
     rec->systembiosmajorversion = get_bios_system_bios_major_release( buf, len );
     rec->systembiosminorversion = get_bios_system_bios_minor_release( buf, len );
-    rec->version                = L"WINE   - 1";
+    rec->version                = L"PROTON - 1";
     if (!match_row( table, row, cond, &status )) free_row_values( table, row );
     else row++;
 
@@ -1468,8 +1468,8 @@ static enum fill_status fill_compsys( struct table *table, const struct expr *co
     rec->description            = L"AT/AT COMPATIBLE";
     rec->domain                 = L"WORKGROUP";
     rec->domainrole             = 0; /* standalone workstation */
-    rec->manufacturer           = L"The Wine Project";
-    rec->model                  = L"Wine";
+    rec->manufacturer           = L"The Proton Project";
+    rec->model                  = L"Proton";
     rec->name                   = get_computername();
     rec->num_logical_processors = get_logical_processor_count( NULL, &rec->num_processors );
     rec->total_physical_memory  = get_total_physical_memory();
@@ -1505,7 +1505,7 @@ static WCHAR *get_compsysproduct_identifyingnumber( const char *buf, UINT len )
 static WCHAR *get_compsysproduct_name( const char *buf, UINT len )
 {
     WCHAR *ret = get_compsysproduct_string( 2, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }
 
@@ -1533,7 +1533,7 @@ done:
 static WCHAR *get_compsysproduct_vendor( const char *buf, UINT len )
 {
     WCHAR *ret = get_compsysproduct_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"The Wine Project" );
+    if (!ret) return heap_strdupW( L"The Proton Project" );
     return ret;
 }
 
@@ -2652,7 +2652,7 @@ static enum fill_status fill_networkadapter( struct table *table, const struct e
         rec->index                = aa->u.s.IfIndex;
         rec->interface_index      = aa->u.s.IfIndex;
         rec->mac_address          = get_mac_address( aa->PhysicalAddress, aa->PhysicalAddressLength );
-        rec->manufacturer         = L"The Wine Project";
+        rec->manufacturer         = L"The Proton Project";
         rec->name                 = heap_strdupW( aa->FriendlyName );
         rec->netconnection_status = get_connection_status( aa->OperStatus );
         rec->physicaladapter      = physical;
@@ -3475,7 +3475,7 @@ static enum fill_status fill_operatingsystem( struct table *table, const struct
     rec->lastbootuptime         = get_lastbootuptime();
     rec->localdatetime          = get_localdatetime();
     rec->locale                 = get_locale();
-    rec->manufacturer           = L"The Wine Project";
+    rec->manufacturer           = L"The Proton Project";
     rec->name                   = get_osname( rec->caption );
     rec->operatingsystemsku     = get_operatingsystemsku();
     rec->osarchitecture         = get_osarchitecture();
@@ -3740,7 +3740,7 @@ static WCHAR *get_systemenclosure_string( BYTE id, const char *buf, UINT len )
 static WCHAR *get_systemenclosure_manufacturer( const char *buf, UINT len )
 {
     WCHAR *ret = get_systemenclosure_string( 1, buf, len );
-    if (!ret) return heap_strdupW( L"Wine" );
+    if (!ret) return heap_strdupW( L"Proton" );
     return ret;
 }
 
@@ -3955,7 +3955,7 @@ static enum fill_status fill_sounddevice( struct table *table, const struct expr
 
     rec = (struct record_sounddevice *)table->data;
     rec->deviceid = get_sounddevice_pnpdeviceid( &desc );
-    rec->manufacturer = L"The Wine Project";
+    rec->manufacturer = L"The Proton Project";
     rec->name = L"Wine Audio Device";
     rec->pnpdeviceid = get_sounddevice_pnpdeviceid( &desc );
     rec->productname = L"Wine Audio Device";
-- 
2.26.2

From 87326687df23529255c2493d178dac1310919980 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 4 Nov 2020 18:08:21 +0300
Subject: [PATCH] ws2_32: HACK Fail 'download-alt.easyanticheat.net' DNS name
 resolution.

This has the same effect as the following reverted ECDHE-ECDSA patch,
but allows those ciphers to be used for other programs.
---
 dlls/ws2_32/socket.c | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 4010a727a08..ef9a640a771 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -6483,6 +6483,13 @@ struct WS_hostent* WINAPI WS_gethostbyname(const char* name)
         extrabuf=HeapAlloc(GetProcessHeap(),0,ebufsize) ;
         while(extrabuf) {
             int res = gethostbyname_r(name, &hostentry, extrabuf, ebufsize, &host, &locerr);
+
+            if (!strcmp(name, "download-alt.easyanticheat.net"))
+            {
+                ERR("HACK: failing download-alt.easyanticheat.net resolution.\n");
+                res = HOST_NOT_FOUND;
+            }
+
             if( res != ERANGE) break;
             ebufsize *=2;
             extrabuf=HeapReAlloc(GetProcessHeap(),0,extrabuf,ebufsize) ;
@@ -6734,6 +6741,13 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
         return WSAHOST_NOT_FOUND;
     }
 
+    if (nodename && !strcmp(nodename, "download-alt.easyanticheat.net"))
+    {
+        ERR("HACK: failing download-alt.easyanticheat.net resolution.\n");
+        SetLastError(WSAHOST_NOT_FOUND);
+        return WSAHOST_NOT_FOUND;
+    }
+
     if (!nodename)
         node = NULL;
     else if (!nodename[0])
From c9a5fcb0966ab0ca0722c8c07476c131844f98e1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 16 Oct 2020 23:37:09 +0200
Subject: [PATCH] dotnetfx35.exe: Add stub program.

This makes it possible to override native dotnetfx35 installer, which
is broken in an unfixable way. Recent Windows versions also bypass its
execution somehow.
---
 configure                       |  2 ++
 configure.ac                    |  1 +
 programs/dotnetfx35/Makefile.in |  7 +++++++
 programs/dotnetfx35/main.c      | 32 ++++++++++++++++++++++++++++++++
 4 files changed, 42 insertions(+)
 create mode 100644 programs/dotnetfx35/Makefile.in
 create mode 100644 programs/dotnetfx35/main.c

diff --git a/configure b/configure
index 848323bb057..d676b1c82ee 100755
--- a/configure
+++ b/configure
@@ -1766,6 +1766,7 @@ enable_conhost
 enable_control
 enable_cscript
 enable_dism
+enable_dotnetfx35
 enable_dplaysvr
 enable_dpnsvr
 enable_dpvsetup
@@ -21579,6 +21580,7 @@ wine_fn_config_makefile programs/conhost enable_conhost
 wine_fn_config_makefile programs/control enable_control
 wine_fn_config_makefile programs/cscript enable_cscript
 wine_fn_config_makefile programs/dism enable_dism
+wine_fn_config_makefile programs/dotnetfx35 enable_dotnetfx35
 wine_fn_config_makefile programs/dplaysvr enable_dplaysvr
 wine_fn_config_makefile programs/dpnsvr enable_dpnsvr
 wine_fn_config_makefile programs/dpvsetup enable_dpvsetup
diff --git a/configure.ac b/configure.ac
index 130dbeb8530..63d26ff123c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -3997,6 +3997,7 @@ WINE_CONFIG_MAKEFILE(programs/conhost)
 WINE_CONFIG_MAKEFILE(programs/control)
 WINE_CONFIG_MAKEFILE(programs/cscript)
 WINE_CONFIG_MAKEFILE(programs/dism)
+WINE_CONFIG_MAKEFILE(programs/dotnetfx35)
 WINE_CONFIG_MAKEFILE(programs/dplaysvr)
 WINE_CONFIG_MAKEFILE(programs/dpnsvr)
 WINE_CONFIG_MAKEFILE(programs/dpvsetup)
diff --git a/programs/dotnetfx35/Makefile.in b/programs/dotnetfx35/Makefile.in
new file mode 100644
index 00000000000..e50ed37f700
--- /dev/null
+++ b/programs/dotnetfx35/Makefile.in
@@ -0,0 +1,7 @@
+MODULE    = dotnetfx35.exe
+IMPORTS   =
+
+EXTRADLLFLAGS = -mwindows -mno-cygwin
+
+C_SRCS = \
+	main.c
diff --git a/programs/dotnetfx35/main.c b/programs/dotnetfx35/main.c
new file mode 100644
index 00000000000..cd6df5bcf41
--- /dev/null
+++ b/programs/dotnetfx35/main.c
@@ -0,0 +1,32 @@
+/*
+ * Fake dotnetfx35.exe installer
+ *
+ * Copyright 2020 Rémi Bernon
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include <stdio.h>
+#include <windows.h>
+
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dotnetfx);
+
+int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
+{
+    FIXME("stub!");
+    return 0;
+}
From: "Rémi Bernon" <rbernon@codeweavers.com>
Subject: [PATCH] server: Only allocate the required size in get_rawinput_buffer.
Message-Id: <20201110133651.553337-1-rbernon@codeweavers.com>
Date: Tue, 10 Nov 2020 14:36:51 +0100

Instead of allocating the maximum reply size.

Signed-off-by: Rémi Bernon <rbernon@codeweavers.com>
---

CoD: WWII calls this with large buffer and it causes a high load on
wineserver, although there may not even be any message to return.

 server/queue.c | 60 ++++++++++++++++++++++++++++++++------------------
 1 file changed, 38 insertions(+), 22 deletions(-)

diff --git a/server/queue.c b/server/queue.c
index 7e7e6fbdf29..3de4d241b8e 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -3251,19 +3251,13 @@ DECL_HANDLER(get_cursor_history)
             pos[i] = cursor_history[(i + cursor_history_latest) % ARRAY_SIZE(cursor_history)];
 }
 
-DECL_HANDLER(get_rawinput_buffer)
+static void copy_rawinput_buffer( struct thread_input *input, char *reply_buf, data_size_t reply_buf_size, data_size_t *reply_size,
+                                  data_size_t client_buf_size, data_size_t client_elt_size, data_size_t *next_size, unsigned int *count )
 {
-    struct thread_input *input = current->queue->input;
-    data_size_t size = 0, next_size = 0;
+    unsigned int n = 0;
     struct list *ptr;
-    char *buf, *cur;
-    int count = 0;
+    char *reply_ptr = reply_buf;
 
-    if (!req->buffer_size) buf = NULL;
-    else if (!(buf = mem_alloc( get_reply_max_size() )))
-        return;
-
-    cur = buf;
     ptr = list_head( &input->msg_list );
     while (ptr)
     {
@@ -3459,22 +3459,44 @@ static void copy_rawinput_buffer( struct thread_input *input, char *reply_buf, d
         ptr = list_next( &input->msg_list, ptr );
         if (msg->msg != WM_INPUT) continue;
 
-        next_size = req->rawinput_size;
-        if (size + next_size > req->buffer_size) break;
-        if (cur + msg_size > buf + get_reply_max_size()) break;
+        if (next_size) *next_size = client_elt_size;
+        if (client_buf_size < client_elt_size) break;
+        if (reply_buf_size < sizeof(*data)) break;
 
-        memcpy(cur, data, msg_size);
-        list_remove( &msg->entry );
-        free_message( msg );
+        if (reply_buf)
+        {
+            memcpy( reply_ptr, data, sizeof(*data) );
+            list_remove( &msg->entry );
+            free_message( msg );
+        }
 
-        size += next_size;
-        cur += msg_size;
-        count++;
+        client_buf_size -= client_elt_size;
+        reply_buf_size -= sizeof(*data);
+        reply_ptr += sizeof(*data);
+        n++;
     }
 
-    reply->next_size = next_size;
-    reply->count = count;
-    set_reply_data_ptr( buf, cur - buf );
+    if (reply_size) *reply_size = reply_ptr - reply_buf;
+    if (count) *count = n;
+}
+
+DECL_HANDLER(get_rawinput_buffer)
+{
+    struct thread_input *input = current->queue->input;
+    data_size_t reply_size;
+    char *reply_buf;
+
+    reply->next_size = 0;
+    reply->count = 0;
+
+    copy_rawinput_buffer( input, NULL, get_reply_max_size(), &reply_size, req->buffer_size,
+                          req->rawinput_size, &reply->next_size, &reply->count );
+
+    if (!req->buffer_size || !reply_size) return;
+    if (!(reply_buf = set_reply_data_size( reply_size ))) return;
+
+    copy_rawinput_buffer( input, reply_buf, reply_size, NULL, req->buffer_size,
+                          req->rawinput_size, NULL, NULL );
 }
 
 DECL_HANDLER(update_rawinput_devices)

-- 
2.29.2
From 85d049746cd99a66fd646d5f97ba76b603bed0cd Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Thu, 10 Dec 2020 14:01:45 -0600
Subject: [PATCH] mmdevapi: Implement SpatialAudio features

---
 dlls/mmdevapi/Makefile.in      |   3 +-
 dlls/mmdevapi/audiovolume.c    |   1 +
 dlls/mmdevapi/devenum.c        |   5 +
 dlls/mmdevapi/main.c           |   1 +
 dlls/mmdevapi/mmdevapi.h       |   1 +
 dlls/mmdevapi/spatialaudio.c   | 948 +++++++++++++++++++++++++++++++++
 include/spatialaudioclient.idl | 121 +++++
 7 files changed, 1079 insertions(+), 1 deletion(-)
 create mode 100644 dlls/mmdevapi/spatialaudio.c

diff --git a/dlls/mmdevapi/Makefile.in b/dlls/mmdevapi/Makefile.in
index 5f44f7ba53b..903b14335a9 100644
--- a/dlls/mmdevapi/Makefile.in
+++ b/dlls/mmdevapi/Makefile.in
@@ -6,6 +6,7 @@ EXTRADLLFLAGS = -mno-cygwin
 C_SRCS = \
 	audiovolume.c \
 	devenum.c \
-	main.c
+	main.c \
+	spatialaudio.c
 
 IDL_SRCS = mmdevapi_classes.idl
diff --git a/dlls/mmdevapi/audiovolume.c b/dlls/mmdevapi/audiovolume.c
index 9214980120e..6f403cf348a 100644
--- a/dlls/mmdevapi/audiovolume.c
+++ b/dlls/mmdevapi/audiovolume.c
@@ -33,6 +33,7 @@
 #include "audioclient.h"
 #include "endpointvolume.h"
 #include "audiopolicy.h"
+#include "spatialaudioclient.h"
 
 #include "mmdevapi.h"
 
diff --git a/dlls/mmdevapi/devenum.c b/dlls/mmdevapi/devenum.c
index 999ec2b0e78..30a2131eab5 100644
--- a/dlls/mmdevapi/devenum.c
+++ b/dlls/mmdevapi/devenum.c
@@ -35,6 +35,7 @@
 #include "audioclient.h"
 #include "endpointvolume.h"
 #include "audiopolicy.h"
+#include "spatialaudioclient.h"
 
 #include "mmdevapi.h"
 #include "devpkey.h"
@@ -658,6 +659,10 @@ static HRESULT WINAPI MMDevice_Activate(IMMDevice *iface, REFIID riid, DWORD cls
                 IDirectSoundCapture_Release((IDirectSoundCapture*)*ppv);
         }
     }
+    else if (IsEqualIID(riid, &IID_ISpatialAudioClient))
+    {
+        hr = SpatialAudioClient_Create(iface, (ISpatialAudioClient**)ppv);
+    }
     else
         ERR("Invalid/unknown iid %s\n", debugstr_guid(riid));
 
diff --git a/dlls/mmdevapi/main.c b/dlls/mmdevapi/main.c
index 8e9127a7507..8dc0b0df820 100644
--- a/dlls/mmdevapi/main.c
+++ b/dlls/mmdevapi/main.c
@@ -37,6 +37,7 @@
 #include "audiopolicy.h"
 #include "devpkey.h"
 #include "winreg.h"
+#include "spatialaudioclient.h"
 
 #include "mmdevapi.h"
 #include "wine/debug.h"
diff --git a/dlls/mmdevapi/mmdevapi.h b/dlls/mmdevapi/mmdevapi.h
index bc9788e95c8..3bcf568cddf 100644
--- a/dlls/mmdevapi/mmdevapi.h
+++ b/dlls/mmdevapi/mmdevapi.h
@@ -71,5 +71,6 @@ typedef struct MMDevice {
 
 extern HRESULT AudioClient_Create(MMDevice *parent, IAudioClient **ppv) DECLSPEC_HIDDEN;
 extern HRESULT AudioEndpointVolume_Create(MMDevice *parent, IAudioEndpointVolumeEx **ppv) DECLSPEC_HIDDEN;
+extern HRESULT SpatialAudioClient_Create(IMMDevice *device, ISpatialAudioClient **out) DECLSPEC_HIDDEN;
 
 extern const WCHAR drv_keyW[] DECLSPEC_HIDDEN;
diff --git a/dlls/mmdevapi/spatialaudio.c b/dlls/mmdevapi/spatialaudio.c
new file mode 100644
index 00000000000..edc28cd9f76
--- /dev/null
+++ b/dlls/mmdevapi/spatialaudio.c
@@ -0,0 +1,948 @@
+/*
+ * Copyright 2020 Andrew Eikum for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#define COBJMACROS
+#define NONAMELESSUNION
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winnls.h"
+#include "winreg.h"
+#include "wine/heap.h"
+#include "wine/debug.h"
+#include "wine/list.h"
+
+#include "ole2.h"
+#include "mmdeviceapi.h"
+#include "mmsystem.h"
+#include "audioclient.h"
+#include "endpointvolume.h"
+#include "audiopolicy.h"
+#include "spatialaudioclient.h"
+
+#include "mmdevapi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(mmdevapi);
+
+#define MAX_PERIODS 3
+
+static UINT32 AudioObjectType_to_index(AudioObjectType type)
+{
+    UINT32 o = 0;
+    while(type){
+        type >>= 1;
+        ++o;
+    }
+    return o - 2;
+}
+
+typedef struct SpatialAudioImpl SpatialAudioImpl;
+typedef struct SpatialAudioStreamImpl SpatialAudioStreamImpl;
+typedef struct SpatialAudioObjectImpl SpatialAudioObjectImpl;
+
+struct SpatialAudioObjectImpl {
+    ISpatialAudioObject ISpatialAudioObject_iface;
+    LONG ref;
+
+    SpatialAudioStreamImpl *sa_stream;
+    AudioObjectType type;
+    UINT32 static_idx;
+
+    float *buf;
+
+    struct list entry;
+};
+
+struct SpatialAudioStreamImpl {
+    ISpatialAudioObjectRenderStream ISpatialAudioObjectRenderStream_iface;
+    LONG ref;
+    CRITICAL_SECTION lock;
+
+    SpatialAudioImpl *sa_client;
+    SpatialAudioObjectRenderStreamActivationParams params;
+
+    IAudioClient *client;
+    IAudioRenderClient *render;
+
+    UINT32 period_frames, update_frames;
+    WAVEFORMATEXTENSIBLE stream_fmtex;
+
+    float *buf;
+
+    UINT32 static_object_map[17];
+
+    struct list objects;
+};
+
+struct SpatialAudioImpl {
+    ISpatialAudioClient ISpatialAudioClient_iface;
+    IAudioFormatEnumerator IAudioFormatEnumerator_iface;
+    IMMDevice *mmdev;
+    LONG ref;
+    WAVEFORMATEXTENSIBLE object_fmtex;
+};
+
+static inline SpatialAudioObjectImpl *impl_from_ISpatialAudioObject(ISpatialAudioObject *iface)
+{
+    return CONTAINING_RECORD(iface, SpatialAudioObjectImpl, ISpatialAudioObject_iface);
+}
+
+static inline SpatialAudioStreamImpl *impl_from_ISpatialAudioObjectRenderStream(ISpatialAudioObjectRenderStream *iface)
+{
+    return CONTAINING_RECORD(iface, SpatialAudioStreamImpl, ISpatialAudioObjectRenderStream_iface);
+}
+
+static inline SpatialAudioImpl *impl_from_ISpatialAudioClient(ISpatialAudioClient *iface)
+{
+    return CONTAINING_RECORD(iface, SpatialAudioImpl, ISpatialAudioClient_iface);
+}
+
+static inline SpatialAudioImpl *impl_from_IAudioFormatEnumerator(IAudioFormatEnumerator *iface)
+{
+    return CONTAINING_RECORD(iface, SpatialAudioImpl, IAudioFormatEnumerator_iface);
+}
+
+static HRESULT WINAPI SAO_QueryInterface(ISpatialAudioObject *iface,
+        REFIID riid, void **ppv)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+
+    TRACE("(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISpatialAudioObjectBase) ||
+            IsEqualIID(riid, &IID_ISpatialAudioObject)) {
+        *ppv = &This->ISpatialAudioObject_iface;
+    }
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+
+    return S_OK;
+}
+
+static ULONG WINAPI SAO_AddRef(ISpatialAudioObject *iface)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI SAO_Release(ISpatialAudioObject *iface)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    if(!ref){
+        EnterCriticalSection(&This->sa_stream->lock);
+        list_remove(&This->entry);
+        LeaveCriticalSection(&This->sa_stream->lock);
+
+        ISpatialAudioObjectRenderStream_Release(&This->sa_stream->ISpatialAudioObjectRenderStream_iface);
+        heap_free(This->buf);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI SAO_GetBuffer(ISpatialAudioObject *iface,
+        BYTE **buffer, UINT32 *bytes)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+
+    TRACE("(%p)->(%p, %p)\n", This, buffer, bytes);
+
+    EnterCriticalSection(&This->sa_stream->lock);
+
+    if(This->sa_stream->update_frames == ~0){
+        LeaveCriticalSection(&This->sa_stream->lock);
+        return SPTLAUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    *buffer = (BYTE *)This->buf;
+    *bytes = This->sa_stream->update_frames *
+        This->sa_stream->sa_client->object_fmtex.Format.nBlockAlign;
+
+    LeaveCriticalSection(&This->sa_stream->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAO_SetEndOfStream(ISpatialAudioObject *iface, UINT32 frames)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    FIXME("(%p)->(%u)\n", This, frames);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAO_IsActive(ISpatialAudioObject *iface, BOOL *active)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    FIXME("(%p)->(%p)\n", This, active);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAO_GetAudioObjectType(ISpatialAudioObject *iface,
+        AudioObjectType *type)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+
+    TRACE("(%p)->(%p)\n", This, type);
+
+    *type = This->type;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAO_SetPosition(ISpatialAudioObject *iface, float x,
+        float y, float z)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    FIXME("(%p)->(%f, %f, %f)\n", This, x, y, z);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAO_SetVolume(ISpatialAudioObject *iface, float vol)
+{
+    SpatialAudioObjectImpl *This = impl_from_ISpatialAudioObject(iface);
+    FIXME("(%p)->(%f)\n", This, vol);
+    return E_NOTIMPL;
+}
+
+static ISpatialAudioObjectVtbl ISpatialAudioObject_vtbl = {
+    SAO_QueryInterface,
+    SAO_AddRef,
+    SAO_Release,
+    SAO_GetBuffer,
+    SAO_SetEndOfStream,
+    SAO_IsActive,
+    SAO_GetAudioObjectType,
+    SAO_SetPosition,
+    SAO_SetVolume,
+};
+
+static HRESULT WINAPI SAORS_QueryInterface(ISpatialAudioObjectRenderStream *iface,
+        REFIID riid, void **ppv)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+
+    TRACE("(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISpatialAudioObjectRenderStreamBase) ||
+            IsEqualIID(riid, &IID_ISpatialAudioObjectRenderStream)) {
+        *ppv = &This->ISpatialAudioObjectRenderStream_iface;
+    }
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+
+    return S_OK;
+}
+
+static ULONG WINAPI SAORS_AddRef(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI SAORS_Release(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    if(!ref){
+        IAudioClient_Stop(This->client);
+        if(This->update_frames != ~0 && This->update_frames > 0)
+            IAudioRenderClient_ReleaseBuffer(This->render, This->update_frames, 0);
+        IAudioRenderClient_Release(This->render);
+        IAudioClient_Release(This->client);
+        if(This->params.NotifyObject)
+            ISpatialAudioObjectRenderStreamNotify_Release(This->params.NotifyObject);
+        heap_free((void*)This->params.ObjectFormat);
+        CloseHandle(This->params.EventHandle);
+        DeleteCriticalSection(&This->lock);
+        ISpatialAudioClient_Release(&This->sa_client->ISpatialAudioClient_iface);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI SAORS_GetAvailableDynamicObjectCount(
+        ISpatialAudioObjectRenderStream *iface, UINT32 *count)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    FIXME("(%p)->(%p)\n", This, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAORS_GetService(ISpatialAudioObjectRenderStream *iface,
+        REFIID riid, void **service)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    FIXME("(%p)->(%s, %p)\n", This, debugstr_guid(riid), service);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAORS_Start(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->()\n", This);
+
+    hr = IAudioClient_Start(This->client);
+    if(FAILED(hr)){
+        WARN("IAudioClient::Start failed: %08x\n", hr);
+        return hr;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAORS_Stop(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->()\n", This);
+
+    hr = IAudioClient_Stop(This->client);
+    if(FAILED(hr)){
+        WARN("IAudioClient::Stop failed: %08x\n", hr);
+        return hr;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAORS_Reset(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    FIXME("(%p)->()\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAORS_BeginUpdatingAudioObjects(ISpatialAudioObjectRenderStream *iface,
+        UINT32 *count, UINT32 *frames)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    SpatialAudioObjectImpl *object;
+    UINT32 pad;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %p)\n", This, count, frames);
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->update_frames != ~0){
+        LeaveCriticalSection(&This->lock);
+        return SPTLAUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    hr = IAudioClient_GetCurrentPadding(This->client, &pad);
+    if(FAILED(hr)){
+        WARN("GetCurrentPadding failed: %08x\n", hr);
+        LeaveCriticalSection(&This->lock);
+        return hr;
+    }
+
+    if(pad < This->period_frames * MAX_PERIODS){
+        This->update_frames = This->period_frames * MAX_PERIODS - pad;
+    }else{
+        This->update_frames = 0;
+    }
+
+    if(This->update_frames > 0){
+        hr = IAudioRenderClient_GetBuffer(This->render, This->update_frames, (BYTE **)&This->buf);
+        if(FAILED(hr)){
+            WARN("GetBuffer failed: %08x\n", hr);
+            This->update_frames = ~0;
+            LeaveCriticalSection(&This->lock);
+            return hr;
+        }
+
+        *count = 0;
+        LIST_FOR_EACH_ENTRY(object, &This->objects, SpatialAudioObjectImpl, entry){
+            memset(object->buf, 0, This->update_frames * This->sa_client->object_fmtex.Format.nBlockAlign);
+            *count += 1;
+        }
+    }else{
+        *count = list_count(&This->objects);
+    }
+
+    *frames = This->update_frames;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static void mix_static_object(SpatialAudioStreamImpl *stream, SpatialAudioObjectImpl *object)
+{
+    float *in = object->buf, *out;
+    UINT32 i;
+    if(object->static_idx == ~0 ||
+            stream->static_object_map[object->static_idx] == ~0){
+        WARN("Got unmapped static object?! Not mixing. Type: 0x%x\n", object->type);
+        return;
+    }
+    out = stream->buf + stream->static_object_map[object->static_idx];
+    for(i = 0; i < stream->update_frames; ++i){
+        *out += *in;
+        ++in;
+        out += stream->stream_fmtex.Format.nChannels;
+    }
+}
+
+static HRESULT WINAPI SAORS_EndUpdatingAudioObjects(ISpatialAudioObjectRenderStream *iface)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    SpatialAudioObjectImpl *object;
+    HRESULT hr;
+
+    TRACE("(%p)->()\n", This);
+
+    EnterCriticalSection(&This->lock);
+
+    if(This->update_frames == ~0){
+        LeaveCriticalSection(&This->lock);
+        return SPTLAUDCLNT_E_OUT_OF_ORDER;
+    }
+
+    if(This->update_frames > 0){
+        LIST_FOR_EACH_ENTRY(object, &This->objects, SpatialAudioObjectImpl, entry){
+            if(object->type != AudioObjectType_Dynamic)
+                mix_static_object(This, object);
+            else
+                WARN("Don't know how to mix dynamic object yet. %p\n", object);
+        }
+
+        hr = IAudioRenderClient_ReleaseBuffer(This->render, This->update_frames, 0);
+        if(FAILED(hr))
+            WARN("ReleaseBuffer failed: %08x\n", hr);
+    }
+
+    This->update_frames = ~0;
+
+    LeaveCriticalSection(&This->lock);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAORS_ActivateSpatialAudioObject(ISpatialAudioObjectRenderStream *iface,
+        AudioObjectType type, ISpatialAudioObject **object)
+{
+    SpatialAudioStreamImpl *This = impl_from_ISpatialAudioObjectRenderStream(iface);
+    SpatialAudioObjectImpl *obj;
+
+    TRACE("(%p)->(0x%x, %p)\n", This, type, object);
+
+    obj = heap_alloc_zero(sizeof(*obj));
+    obj->ISpatialAudioObject_iface.lpVtbl = &ISpatialAudioObject_vtbl;
+    obj->ref = 1;
+    obj->type = type;
+    if(type == AudioObjectType_Dynamic){
+        FIXME("AudioObjectType_Dynamic not implemented yet!\n");
+        obj->static_idx = ~0;
+    }else if(type == AudioObjectType_None){
+        FIXME("AudioObjectType_None not implemented yet!\n");
+        obj->static_idx = ~0;
+    }else{
+        obj->static_idx = AudioObjectType_to_index(type);
+    }
+
+    obj->sa_stream = This;
+    SAORS_AddRef(&This->ISpatialAudioObjectRenderStream_iface);
+
+    obj->buf = heap_alloc_zero(This->period_frames * MAX_PERIODS * This->sa_client->object_fmtex.Format.nBlockAlign);
+
+    EnterCriticalSection(&This->lock);
+
+    list_add_tail(&This->objects, &obj->entry);
+
+    LeaveCriticalSection(&This->lock);
+
+    *object = &obj->ISpatialAudioObject_iface;
+
+    return S_OK;
+}
+
+static ISpatialAudioObjectRenderStreamVtbl ISpatialAudioObjectRenderStream_vtbl = {
+    SAORS_QueryInterface,
+    SAORS_AddRef,
+    SAORS_Release,
+    SAORS_GetAvailableDynamicObjectCount,
+    SAORS_GetService,
+    SAORS_Start,
+    SAORS_Stop,
+    SAORS_Reset,
+    SAORS_BeginUpdatingAudioObjects,
+    SAORS_EndUpdatingAudioObjects,
+    SAORS_ActivateSpatialAudioObject,
+};
+
+static HRESULT WINAPI SAC_QueryInterface(ISpatialAudioClient *iface, REFIID riid, void **ppv)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+
+    TRACE("(%p)->(%s,%p)\n", This, debugstr_guid(riid), ppv);
+
+    if (!ppv)
+        return E_POINTER;
+
+    *ppv = NULL;
+
+    if (IsEqualIID(riid, &IID_IUnknown) ||
+            IsEqualIID(riid, &IID_ISpatialAudioClient)) {
+        *ppv = &This->ISpatialAudioClient_iface;
+    }
+    else
+        return E_NOINTERFACE;
+
+    IUnknown_AddRef((IUnknown *)*ppv);
+
+    return S_OK;
+}
+
+static ULONG WINAPI SAC_AddRef(ISpatialAudioClient *iface)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    ULONG ref = InterlockedIncrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    return ref;
+}
+
+static ULONG WINAPI SAC_Release(ISpatialAudioClient *iface)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    ULONG ref = InterlockedDecrement(&This->ref);
+    TRACE("(%p) new ref %u\n", This, ref);
+    if (!ref) {
+        IMMDevice_Release(This->mmdev);
+        heap_free(This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI SAC_GetStaticObjectPosition(ISpatialAudioClient *iface,
+        AudioObjectType type, float *x, float *y, float *z)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    FIXME("(%p)->(0x%x, %p, %p, %p)\n", This, type, x, y, z);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAC_GetNativeStaticObjectTypeMask(ISpatialAudioClient *iface,
+        AudioObjectType *mask)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    FIXME("(%p)->(%p)\n", This, mask);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAC_GetMaxDynamicObjectCount(ISpatialAudioClient *iface,
+        UINT32 *value)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    FIXME("(%p)->(%p)\n", This, value);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAC_GetSupportedAudioObjectFormatEnumerator(
+        ISpatialAudioClient *iface, IAudioFormatEnumerator **enumerator)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+
+    TRACE("(%p)->(%p)\n", This, enumerator);
+
+    *enumerator = &This->IAudioFormatEnumerator_iface;
+    SAC_AddRef(iface);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAC_GetMaxFrameCount(ISpatialAudioClient *iface,
+        const WAVEFORMATEX *format, UINT32 *count)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+
+    /* FIXME: should get device period from the device */
+    static const REFERENCE_TIME period = 100000;
+
+    TRACE("(%p)->(%p, %p)\n", This, format, count);
+
+    *count = MulDiv(period, format->nSamplesPerSec, 10000000) * MAX_PERIODS;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAC_IsAudioObjectFormatSupported(ISpatialAudioClient *iface,
+        const WAVEFORMATEX *format)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    FIXME("(%p)->(%p)\n", This, format);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI SAC_IsSpatialAudioStreamAvailable(ISpatialAudioClient *iface,
+        REFIID stream_uuid, const PROPVARIANT *info)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    FIXME("(%p)->(%s, %p)\n", This, debugstr_guid(stream_uuid), info);
+    return E_NOTIMPL;
+}
+
+static WAVEFORMATEX *clone_fmtex(const WAVEFORMATEX *src)
+{
+    WAVEFORMATEX *r = heap_alloc(sizeof(WAVEFORMATEX) + src->cbSize);
+    memcpy(r, src, sizeof(WAVEFORMATEX) + src->cbSize);
+    return r;
+}
+
+static const char *debugstr_fmtex(const WAVEFORMATEX *fmt)
+{
+    static char buf[2048];
+    if(fmt->wFormatTag == WAVE_FORMAT_EXTENSIBLE){
+        const WAVEFORMATEXTENSIBLE *fmtex = (const WAVEFORMATEXTENSIBLE *)fmt;
+        snprintf(buf, sizeof(buf), "tag: 0x%x (%s), ch: %u (mask: 0x%x), rate: %u, depth: %u",
+                fmt->wFormatTag, debugstr_guid(&fmtex->SubFormat),
+                fmt->nChannels, fmtex->dwChannelMask, fmt->nSamplesPerSec,
+                fmt->wBitsPerSample);
+    }else{
+        snprintf(buf, sizeof(buf), "tag: 0x%x, ch: %u, rate: %u, depth: %u",
+                fmt->wFormatTag, fmt->nChannels, fmt->nSamplesPerSec,
+                fmt->wBitsPerSample);
+    }
+    return buf;
+}
+
+static void static_mask_to_channels(AudioObjectType static_mask, WORD *count, DWORD *mask, UINT32 *map)
+{
+    UINT32 out_chan = 0, map_idx = 0;
+    *count = 0;
+    *mask = 0;
+#define CONVERT_MASK(f, t) \
+    if(static_mask & f){ \
+        *count += 1; \
+        *mask |= t; \
+        map[map_idx++] = out_chan++; \
+        TRACE("mapping 0x%x to %u\n", f, out_chan - 1); \
+    }else{ \
+        map[map_idx++] = ~0; \
+    }
+    CONVERT_MASK(AudioObjectType_FrontLeft, SPEAKER_FRONT_LEFT);
+    CONVERT_MASK(AudioObjectType_FrontRight, SPEAKER_FRONT_RIGHT);
+    CONVERT_MASK(AudioObjectType_FrontCenter, SPEAKER_FRONT_CENTER);
+    CONVERT_MASK(AudioObjectType_LowFrequency, SPEAKER_LOW_FREQUENCY);
+    CONVERT_MASK(AudioObjectType_SideLeft, SPEAKER_SIDE_LEFT);
+    CONVERT_MASK(AudioObjectType_SideRight, SPEAKER_SIDE_RIGHT);
+    CONVERT_MASK(AudioObjectType_BackLeft, SPEAKER_BACK_LEFT);
+    CONVERT_MASK(AudioObjectType_BackRight, SPEAKER_BACK_RIGHT);
+    CONVERT_MASK(AudioObjectType_TopFrontLeft, SPEAKER_TOP_FRONT_LEFT);
+    CONVERT_MASK(AudioObjectType_TopFrontRight, SPEAKER_TOP_FRONT_RIGHT);
+    CONVERT_MASK(AudioObjectType_TopBackLeft, SPEAKER_TOP_BACK_LEFT);
+    CONVERT_MASK(AudioObjectType_TopBackRight, SPEAKER_TOP_BACK_RIGHT);
+    CONVERT_MASK(AudioObjectType_BackCenter, SPEAKER_BACK_CENTER);
+}
+
+static HRESULT activate_stream(SpatialAudioStreamImpl *stream)
+{
+    WAVEFORMATEXTENSIBLE *object_fmtex = (WAVEFORMATEXTENSIBLE *)stream->params.ObjectFormat;
+    HRESULT hr;
+    REFERENCE_TIME period;
+
+    if(!(object_fmtex->Format.wFormatTag == WAVE_FORMAT_IEEE_FLOAT ||
+                (object_fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
+                 IsEqualGUID(&object_fmtex->SubFormat, &KSDATAFORMAT_SUBTYPE_IEEE_FLOAT)))){
+        FIXME("Only float formats are supported for now\n");
+        return E_INVALIDARG;
+    }
+
+    hr = IMMDevice_Activate(stream->sa_client->mmdev, &IID_IAudioClient,
+            CLSCTX_INPROC_SERVER, NULL, (void**)&stream->client);
+    if(FAILED(hr)){
+        WARN("Activate failed: %08x\n", hr);
+        return hr;
+    }
+
+    hr = IAudioClient_GetDevicePeriod(stream->client, &period, NULL);
+    if(FAILED(hr)){
+        WARN("GetDevicePeriod failed: %08x\n", hr);
+        IAudioClient_Release(stream->client);
+        return hr;
+    }
+
+    stream->stream_fmtex.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    static_mask_to_channels(stream->params.StaticObjectTypeMask,
+            &stream->stream_fmtex.Format.nChannels, &stream->stream_fmtex.dwChannelMask,
+            stream->static_object_map);
+    stream->stream_fmtex.Format.nSamplesPerSec = stream->params.ObjectFormat->nSamplesPerSec;
+    stream->stream_fmtex.Format.wBitsPerSample = stream->params.ObjectFormat->wBitsPerSample;
+    stream->stream_fmtex.Format.nBlockAlign = (stream->stream_fmtex.Format.nChannels * stream->stream_fmtex.Format.wBitsPerSample) / 8;
+    stream->stream_fmtex.Format.nAvgBytesPerSec = stream->stream_fmtex.Format.nSamplesPerSec * stream->stream_fmtex.Format.nBlockAlign;
+    stream->stream_fmtex.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMATEX);
+    stream->stream_fmtex.Samples.wValidBitsPerSample = stream->stream_fmtex.Format.wBitsPerSample;
+    stream->stream_fmtex.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+
+    hr = IAudioClient_Initialize(stream->client, AUDCLNT_SHAREMODE_SHARED,
+            AUDCLNT_STREAMFLAGS_EVENTCALLBACK | AUDCLNT_STREAMFLAGS_NOPERSIST,
+            period * MAX_PERIODS, 0, &stream->stream_fmtex.Format, NULL);
+    if(FAILED(hr)){
+        WARN("Initialize failed: %08x\n", hr);
+        IAudioClient_Release(stream->client);
+        return hr;
+    }
+
+    /* XXX: OK that this is the user's handle? */
+    hr = IAudioClient_SetEventHandle(stream->client, stream->params.EventHandle);
+    if(FAILED(hr)){
+        WARN("SetEventHandle failed: %08x\n", hr);
+        IAudioClient_Release(stream->client);
+        return hr;
+    }
+
+    hr = IAudioClient_GetService(stream->client, &IID_IAudioRenderClient, (void**)&stream->render);
+    if(FAILED(hr)){
+        WARN("GetService(AudioRenderClient) failed: %08x\n", hr);
+        IAudioClient_Release(stream->client);
+        return hr;
+    }
+
+    stream->period_frames = MulDiv(period, stream->stream_fmtex.Format.nSamplesPerSec, 10000000);
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAC_ActivateSpatialAudioStream(ISpatialAudioClient *iface,
+        const PROPVARIANT *params, REFIID riid, void **stream)
+{
+    SpatialAudioImpl *This = impl_from_ISpatialAudioClient(iface);
+    HRESULT hr;
+
+    TRACE("(%p)->(%s, %p)\n", This, debugstr_guid(riid), stream);
+
+    if(IsEqualIID(riid, &IID_ISpatialAudioObjectRenderStream)){
+        SpatialAudioStreamImpl *obj;
+
+        if(params &&
+                (params->vt != VT_BLOB ||
+                 params->u.blob.cbSize != sizeof(SpatialAudioObjectRenderStreamActivationParams))){
+            WARN("Got invalid params\n");
+            return E_INVALIDARG;
+        }
+
+        obj = heap_alloc_zero(sizeof(SpatialAudioStreamImpl));
+
+        obj->ISpatialAudioObjectRenderStream_iface.lpVtbl = &ISpatialAudioObjectRenderStream_vtbl;
+        obj->ref = 1;
+        memcpy(&obj->params, params->u.blob.pBlobData, sizeof(obj->params));
+
+        obj->update_frames = ~0;
+
+        InitializeCriticalSection(&obj->lock);
+        list_init(&obj->objects);
+
+        obj->sa_client = This;
+        SAC_AddRef(&This->ISpatialAudioClient_iface);
+
+        obj->params.ObjectFormat = clone_fmtex(obj->params.ObjectFormat);
+
+        if(obj->params.EventHandle != INVALID_HANDLE_VALUE &&
+                obj->params.EventHandle != 0)
+            DuplicateHandle(GetCurrentProcess(), obj->params.EventHandle,
+                    GetCurrentProcess(), &obj->params.EventHandle, 0, FALSE,
+                    DUPLICATE_SAME_ACCESS);
+
+        if(obj->params.NotifyObject)
+            ISpatialAudioObjectRenderStreamNotify_AddRef(obj->params.NotifyObject);
+
+        if(TRACE_ON(mmdevapi)){
+            TRACE("ObjectFormat: {%s}\n", debugstr_fmtex(obj->params.ObjectFormat));
+            TRACE("StaticObjectTypeMask: 0x%x\n", obj->params.StaticObjectTypeMask);
+            TRACE("MinDynamicObjectCount: 0x%x\n", obj->params.MinDynamicObjectCount);
+            TRACE("MaxDynamicObjectCount: 0x%x\n", obj->params.MaxDynamicObjectCount);
+            TRACE("Category: 0x%x\n", obj->params.Category);
+            TRACE("EventHandle: %p\n", obj->params.EventHandle);
+            TRACE("NotifyObject: %p\n", obj->params.NotifyObject);
+        }
+
+        hr = activate_stream(obj);
+        if(FAILED(hr)){
+            if(obj->params.NotifyObject)
+                ISpatialAudioObjectRenderStreamNotify_Release(obj->params.NotifyObject);
+            DeleteCriticalSection(&obj->lock);
+            heap_free((void*)obj->params.ObjectFormat);
+            CloseHandle(obj->params.EventHandle);
+            ISpatialAudioClient_Release(&obj->sa_client->ISpatialAudioClient_iface);
+            heap_free(obj);
+            return hr;
+        }
+
+        *stream = &obj->ISpatialAudioObjectRenderStream_iface;
+    }else{
+        FIXME("Unsupported audio stream IID: %s\n", debugstr_guid(riid));
+        *stream = NULL;
+        return E_NOTIMPL;
+    }
+
+    return S_OK;
+}
+
+static ISpatialAudioClientVtbl ISpatialAudioClient_vtbl = {
+    SAC_QueryInterface,
+    SAC_AddRef,
+    SAC_Release,
+    SAC_GetStaticObjectPosition,
+    SAC_GetNativeStaticObjectTypeMask,
+    SAC_GetMaxDynamicObjectCount,
+    SAC_GetSupportedAudioObjectFormatEnumerator,
+    SAC_GetMaxFrameCount,
+    SAC_IsAudioObjectFormatSupported,
+    SAC_IsSpatialAudioStreamAvailable,
+    SAC_ActivateSpatialAudioStream,
+};
+
+static HRESULT WINAPI SAOFE_QueryInterface(IAudioFormatEnumerator *iface,
+        REFIID riid, void **ppvObject)
+{
+    SpatialAudioImpl *This = impl_from_IAudioFormatEnumerator(iface);
+    return SAC_QueryInterface(&This->ISpatialAudioClient_iface, riid, ppvObject);
+}
+
+static ULONG WINAPI SAOFE_AddRef(IAudioFormatEnumerator *iface)
+{
+    SpatialAudioImpl *This = impl_from_IAudioFormatEnumerator(iface);
+    return SAC_AddRef(&This->ISpatialAudioClient_iface);
+}
+
+static ULONG WINAPI SAOFE_Release(IAudioFormatEnumerator *iface)
+{
+    SpatialAudioImpl *This = impl_from_IAudioFormatEnumerator(iface);
+    return SAC_Release(&This->ISpatialAudioClient_iface);
+}
+
+static HRESULT WINAPI SAOFE_GetCount(IAudioFormatEnumerator *iface, UINT32 *count)
+{
+    SpatialAudioImpl *This = impl_from_IAudioFormatEnumerator(iface);
+
+    TRACE("(%p)->(%p)\n", This, count);
+
+    *count = 1;
+
+    return S_OK;
+}
+
+static HRESULT WINAPI SAOFE_GetFormat(IAudioFormatEnumerator *iface,
+        UINT32 index, WAVEFORMATEX **format)
+{
+    SpatialAudioImpl *This = impl_from_IAudioFormatEnumerator(iface);
+
+    TRACE("(%p)->(%u, %p)\n", This, index, format);
+
+    if(index > 0)
+        return E_INVALIDARG;
+
+    *format = &This->object_fmtex.Format;
+
+    return S_OK;
+}
+
+static IAudioFormatEnumeratorVtbl IAudioFormatEnumerator_vtbl = {
+    SAOFE_QueryInterface,
+    SAOFE_AddRef,
+    SAOFE_Release,
+    SAOFE_GetCount,
+    SAOFE_GetFormat,
+};
+
+HRESULT SpatialAudioClient_Create(IMMDevice *mmdev, ISpatialAudioClient **out)
+{
+    SpatialAudioImpl *obj;
+    IPropertyStore *ps;
+    PROPVARIANT pv;
+    HRESULT hr;
+    WAVEFORMATEXTENSIBLE *fmtex;
+
+    hr = IMMDevice_OpenPropertyStore(mmdev, STGM_READ, &ps);
+    if(FAILED(hr)){
+        WARN("OpenPropertyStore failed: %08x\n", hr);
+        return hr;
+    }
+
+    pv.vt = VT_EMPTY;
+    hr = IPropertyStore_GetValue(ps, (const PROPERTYKEY *)&PKEY_AudioEngine_DeviceFormat, &pv);
+    if(FAILED(hr)){
+        WARN("Failed to get DeviceFormat: %08x\n", hr);
+        IPropertyStore_Release(ps);
+        return hr;
+    }
+
+    if(pv.vt != VT_BLOB || pv.u.blob.cbSize == 0){
+        WARN("Got invalid DeviceFormat\n");
+        PropVariantClear(&pv);
+        IPropertyStore_Release(ps);
+        return E_FAIL;
+    }
+
+    obj = heap_alloc_zero(sizeof(*obj));
+
+    obj->ref = 1;
+    obj->ISpatialAudioClient_iface.lpVtbl = &ISpatialAudioClient_vtbl;
+    obj->IAudioFormatEnumerator_iface.lpVtbl = &IAudioFormatEnumerator_vtbl;
+
+    obj->mmdev = mmdev;
+    IMMDevice_AddRef(mmdev);
+
+    fmtex = (WAVEFORMATEXTENSIBLE *)pv.u.blob.pBlobData;
+
+    obj->object_fmtex.Format.wFormatTag = WAVE_FORMAT_EXTENSIBLE;
+    obj->object_fmtex.Format.nChannels = 1;
+    obj->object_fmtex.Format.nSamplesPerSec = fmtex->Format.nSamplesPerSec;
+    obj->object_fmtex.Format.wBitsPerSample = sizeof(float) * 8;
+    obj->object_fmtex.Format.nBlockAlign = (obj->object_fmtex.Format.nChannels * obj->object_fmtex.Format.wBitsPerSample) / 8;
+    obj->object_fmtex.Format.nAvgBytesPerSec = obj->object_fmtex.Format.nSamplesPerSec * obj->object_fmtex.Format.nBlockAlign;
+    obj->object_fmtex.Format.cbSize = sizeof(WAVEFORMATEXTENSIBLE) - sizeof(WAVEFORMAT);
+    obj->object_fmtex.Samples.wValidBitsPerSample = obj->object_fmtex.Format.wBitsPerSample;
+    obj->object_fmtex.dwChannelMask = 0;
+    obj->object_fmtex.SubFormat = KSDATAFORMAT_SUBTYPE_IEEE_FLOAT;
+
+    PropVariantClear(&pv);
+    IPropertyStore_Release(ps);
+
+    *out = &obj->ISpatialAudioClient_iface;
+
+    return S_OK;
+}
diff --git a/include/spatialaudioclient.idl b/include/spatialaudioclient.idl
index 16a1541fd1d..08c84965566 100644
--- a/include/spatialaudioclient.idl
+++ b/include/spatialaudioclient.idl
@@ -43,6 +43,47 @@ typedef [v1_enum] enum AudioObjectType
     AudioObjectType_BackCenter       = 0x00020000,
 } AudioObjectType;
 
+cpp_quote("#define SPTLAUDCLNT_E_DESTROYED                     AUDCLNT_ERR(0x100)")
+cpp_quote("#define SPTLAUDCLNT_E_OUT_OF_ORDER                  AUDCLNT_ERR(0x101)")
+cpp_quote("#define SPTLAUDCLNT_E_RESOURCES_INVALIDATED         AUDCLNT_ERR(0x102)")
+cpp_quote("#define SPTLAUDCLNT_E_NO_MORE_OBJECTS               AUDCLNT_ERR(0x103)")
+cpp_quote("#define SPTLAUDCLNT_E_PROPERTY_NOT_SUPPORTED        AUDCLNT_ERR(0x104)")
+cpp_quote("#define SPTLAUDCLNT_E_ERRORS_IN_OBJECT_CALLS        AUDCLNT_ERR(0x105)")
+cpp_quote("#define SPTLAUDCLNT_E_METADATA_FORMAT_NOT_SUPPORTED AUDCLNT_ERR(0x106)")
+cpp_quote("#define SPTLAUDCLNT_E_STREAM_NOT_AVAILABLE          AUDCLNT_ERR(0x107)")
+cpp_quote("#define SPTLAUDCLNT_E_INVALID_LICENSE               AUDCLNT_ERR(0x108)")
+cpp_quote("#define SPTLAUDCLNT_E_STREAM_NOT_STOPPED            AUDCLNT_ERR(0x10a)")
+cpp_quote("#define SPTLAUDCLNT_E_STATIC_OBJECT_NOT_AVAILABLE   AUDCLNT_ERR(0x10b)")
+cpp_quote("#define SPTLAUDCLNT_E_OBJECT_ALREADY_ACTIVE         AUDCLNT_ERR(0x10c)")
+cpp_quote("#define SPTLAUDCLNT_E_INTERNAL                      AUDCLNT_ERR(0x10d)")
+
+interface ISpatialAudioObjectRenderStreamBase;
+
+[
+    object,
+    uuid(dddf83e6-68d7-4c70-883f-a1836afb4a50),
+    pointer_default(unique),
+    local
+]
+interface ISpatialAudioObjectRenderStreamNotify : IUnknown
+{
+    HRESULT OnAvailableDynamicObjectCountChange(
+        [in] ISpatialAudioObjectRenderStreamBase *stream,
+        [in] LONGLONG deadline,
+        [in] UINT32 object_count);
+}
+
+typedef struct tagSpatialAudioObjectRenderStreamActivationParams
+{
+    const WAVEFORMATEX *ObjectFormat;
+    AudioObjectType StaticObjectTypeMask;
+    UINT32 MinDynamicObjectCount;
+    UINT32 MaxDynamicObjectCount;
+    AUDIO_STREAM_CATEGORY Category;
+    HANDLE EventHandle;
+    ISpatialAudioObjectRenderStreamNotify *NotifyObject;
+} SpatialAudioObjectRenderStreamActivationParams;
+
 [
     object,
     uuid(dcdaa858-895a-4a22-a5eb-67bda506096d),
@@ -98,3 +139,83 @@ interface ISpatialAudioClient : IUnknown
         [in] REFIID riid,
         [out, iid_is(riid)] void **stream);
 }
+
+[
+    object,
+    uuid(cce0b8f2-8d4d-4efb-a8cf-3d6ecf1c30e0),
+    pointer_default(unique),
+    local
+]
+interface ISpatialAudioObjectBase : IUnknown
+{
+    HRESULT GetBuffer(
+        [out] BYTE **buffer,
+        [out] UINT32 *bytes);
+
+    HRESULT SetEndOfStream(
+        [in] UINT32 frames);
+
+    HRESULT IsActive(
+        [out] BOOL *active);
+
+    HRESULT GetAudioObjectType(
+        [out] AudioObjectType *type);
+}
+
+[
+    object,
+    uuid(dde28967-521b-46e5-8f00-bd6f2bc8ab1d),
+    pointer_default(unique),
+    local
+]
+interface ISpatialAudioObject : ISpatialAudioObjectBase
+{
+    HRESULT SetPosition(
+        [in] float x,
+        [in] float y,
+        [in] float z);
+
+    HRESULT SetVolume(
+        [in] float vol);
+}
+
+[
+    object,
+    uuid(feaaf403-c1d8-450d-aa05-e0ccee7502a8),
+    pointer_default(unique),
+    local
+]
+interface ISpatialAudioObjectRenderStreamBase : IUnknown
+{
+    HRESULT GetAvailableDynamicObjectCount(
+        [out] UINT32 *count);
+
+    HRESULT GetService(
+        [in] REFIID riid,
+        [out] void **service);
+
+    HRESULT Start();
+
+    HRESULT Stop();
+
+    HRESULT Reset();
+
+    HRESULT BeginUpdatingAudioObjects(
+        [out] UINT32 *count,
+        [out] UINT32 *frames);
+
+    HRESULT EndUpdatingAudioObjects();
+}
+
+[
+    object,
+    uuid(bab5f473-b423-477b-85f5-b5a332a04153),
+    pointer_default(unique),
+    local
+]
+interface ISpatialAudioObjectRenderStream : ISpatialAudioObjectRenderStreamBase
+{
+    HRESULT ActivateSpatialAudioObject(
+        [in] AudioObjectType type,
+        [out] ISpatialAudioObject **object);
+}
From e6c96f88d8f78a9890a5b96a8e85406ad9695f3c Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 2 Nov 2020 23:03:20 +0300
Subject: [PATCH] ntdll: (HACK) Add variable to report all logical CPUs as
 physical cores.

---
 dlls/ntdll/unix/system.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index 0b83761ed46..bf3d6c34f14 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -830,7 +830,8 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
     static const char core_info[] = "/sys/devices/system/cpu/cpu%u/topology/%s";
     static const char cache_info[] = "/sys/devices/system/cpu/cpu%u/cache/index%u/%s";
     static const char numa_info[] = "/sys/devices/system/node/node%u/cpumap";
-
+    const char *env_fake_logical_cores = getenv("WINE_LOGICAL_CPUS_AS_CORES");
+    BOOL fake_logical_cpus_as_cores = env_fake_logical_cores && atoi(env_fake_logical_cores);
     FILE *fcpu_list, *fnuma_list, *f;
     DWORD len = 0, beg, end, i, j, r, num_cpus = 0, max_cpus = 0;
     char op, name[MAX_PATH];
@@ -902,7 +903,7 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
             {
                 /* Mask of logical threads sharing same physical core in kernel core numbering. */
                 sprintf(name, core_info, i, "thread_siblings");
-                if(!sysfs_parse_bitmap(name, &thread_mask)) thread_mask = 1<<i;
+                if(fake_logical_cpus_as_cores || !sysfs_parse_bitmap(name, &thread_mask)) thread_mask = (ULONG_PTR)1<<i;
 
                 /* Needed later for NumaNode and Group. */
                 all_cpus_mask |= thread_mask;
@@ -910,7 +911,7 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
                 if (relation == RelationAll || relation == RelationProcessorCore)
                 {
                     sprintf(name, core_info, i, "thread_siblings_list");
-                    f = fopen(name, "r");
+                    f = fake_logical_cpus_as_cores ? NULL : fopen(name, "r");
                     if (f)
                     {
                         fscanf(f, "%d%c", &phys_core, &op);
From 2a3179a431c0b8df72f75ef5f134bd0098fabdc0 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 20 Nov 2020 18:01:11 +0300
Subject: [PATCH] ntdll: Implement CPU topology override.

---
 dlls/ntdll/unix/server.c       |   3 +
 dlls/ntdll/unix/system.c       | 167 ++++++++++++++++++++++++++++++---
 dlls/ntdll/unix/thread.c       |  15 ++-
 dlls/ntdll/unix/unix_private.h |   1 +
 include/wine/server_protocol.h |   9 +-
 server/process.c               |   7 ++
 server/process.h               |   1 +
 server/protocol.def            |   7 ++
 server/thread.c                |  20 +++-
 server/trace.c                 |  19 ++++
 10 files changed, 228 insertions(+), 21 deletions(-)

diff --git a/dlls/ntdll/unix/server.c b/dlls/ntdll/unix/server.c
index b1d3e863240..7b0c7c32f58 100644
--- a/dlls/ntdll/unix/server.c
+++ b/dlls/ntdll/unix/server.c
@@ -1467,6 +1467,7 @@ void CDECL server_init_process_done( void *relay )
     PEB *peb = NtCurrentTeb()->Peb;
     IMAGE_NT_HEADERS *nt = get_exe_nt_header();
     void *entry = (char *)peb->ImageBaseAddress + nt->OptionalHeader.AddressOfEntryPoint;
+    struct cpu_topology_override *cpu_override = get_cpu_topology_override();
     NTSTATUS status;
     int suspend;
 
@@ -1488,6 +1489,8 @@ void CDECL server_init_process_done( void *relay )
 #endif
         req->entry    = wine_server_client_ptr( entry );
         req->gui      = (nt->OptionalHeader.Subsystem != IMAGE_SUBSYSTEM_WINDOWS_CUI);
+        if (cpu_override)
+            wine_server_add_data( req, cpu_override, sizeof(*cpu_override) );
         status = wine_server_call( req );
         suspend = reply->suspend;
     }
diff --git a/dlls/ntdll/unix/system.c b/dlls/ntdll/unix/system.c
index bf3d6c34f14..fc8165f2828 100644
--- a/dlls/ntdll/unix/system.c
+++ b/dlls/ntdll/unix/system.c
@@ -29,6 +29,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>
+#include <assert.h>
 #ifdef HAVE_SYS_TIME_H
 # include <sys/time.h>
 #endif
@@ -165,6 +166,12 @@ struct smbios_boot_info
 #define RSMB 0x52534D42
 
 static SYSTEM_CPU_INFORMATION cpu_info;
+static struct
+{
+    struct cpu_topology_override mapping;
+    BOOL smt;
+}
+cpu_override;
 
 /*******************************************************************************
  * Architecture specific feature detection for CPUs
@@ -475,6 +482,88 @@ static void get_cpuinfo( SYSTEM_CPU_INFORMATION *info )
 
 #endif /* End architecture specific feature detection for CPUs */
 
+static void fill_cpu_override(unsigned int host_cpu_count)
+{
+    const char *env_override = getenv("WINE_CPU_TOPOLOGY");
+    unsigned int i;
+    char *s;
+
+    if (!env_override)
+        return;
+
+    cpu_override.mapping.cpu_count = strtol(env_override, &s, 10);
+    if (s == env_override)
+        goto error;
+
+    if (!cpu_override.mapping.cpu_count || cpu_override.mapping.cpu_count > MAXIMUM_PROCESSORS)
+    {
+        ERR("Invalid logical CPU count %u, limit %u.\n", cpu_override.mapping.cpu_count, MAXIMUM_PROCESSORS);
+        goto error;
+    }
+
+    if (tolower(*s) == 's')
+    {
+        cpu_override.mapping.cpu_count *= 2;
+        if (cpu_override.mapping.cpu_count > MAXIMUM_PROCESSORS)
+        {
+            ERR("Logical CPU count exceeds limit %u.\n", MAXIMUM_PROCESSORS);
+            goto error;
+        }
+        cpu_override.smt = TRUE;
+        ++s;
+    }
+    if (*s != ':')
+        goto error;
+    ++s;
+    for (i = 0; i < cpu_override.mapping.cpu_count; ++i)
+    {
+        char *next;
+
+        if (i)
+        {
+            if (*s != ',')
+            {
+                if (!*s)
+                    ERR("Incomplete host CPU mapping string, %u CPUs mapping required.\n",
+                            cpu_override.mapping.cpu_count);
+                goto error;
+            }
+            ++s;
+        }
+
+        cpu_override.mapping.host_cpu_id[i] = strtol(s, &next, 10);
+        if (next == s)
+            goto error;
+        if (cpu_override.mapping.host_cpu_id[i] >= host_cpu_count)
+        {
+            ERR("Invalid host CPU index %u (host_cpu_count %u).\n",
+                    cpu_override.mapping.host_cpu_id[i], host_cpu_count);
+            goto error;
+        }
+        s = next;
+    }
+    if (*s)
+        goto error;
+
+    ERR("Overriding CPU configuration, %u logical CPUs, host CPUs ", cpu_override.mapping.cpu_count);
+    for (i = 0; i < cpu_override.mapping.cpu_count; ++i)
+    {
+        if (i)
+            ERR(",");
+        ERR("%u", cpu_override.mapping.host_cpu_id[i]);
+    }
+    ERR("\n");
+    return;
+error:
+    cpu_override.mapping.cpu_count = 0;
+    ERR("Invalid WINE_CPU_TOPOLOGY string %s (%s).\n", debugstr_a(env_override), debugstr_a(s));
+}
+
+struct cpu_topology_override *get_cpu_topology_override(void)
+{
+    return cpu_override.mapping.cpu_count ? &cpu_override.mapping : NULL;
+}
+
 /******************************************************************
  *		init_cpu_info
  *
@@ -508,7 +597,11 @@ void init_cpu_info(void)
     num = 1;
     FIXME("Detecting the number of processors is not supported.\n");
 #endif
-    NtCurrentTeb()->Peb->NumberOfProcessors = num;
+
+    fill_cpu_override(num);
+
+    NtCurrentTeb()->Peb->NumberOfProcessors = cpu_override.mapping.cpu_count
+            ? cpu_override.mapping.cpu_count : num;
     get_cpuinfo( &cpu_info );
     TRACE( "<- CPU arch %d, level %d, rev %d, features 0x%x\n",
            cpu_info.Architecture, cpu_info.Level, cpu_info.Revision, cpu_info.FeatureSet );
@@ -860,6 +953,12 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
         if (op == '-') fscanf(fcpu_list, "%u%c ", &end, &op);
         else end = beg;
 
+        if (cpu_override.mapping.cpu_count)
+        {
+            beg = 0;
+            end = cpu_override.mapping.cpu_count - 1;
+        }
+
         for(i = beg; i <= end; i++)
         {
             DWORD phys_core = 0;
@@ -873,7 +972,9 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
 
             if (relation == RelationAll || relation == RelationProcessorPackage)
             {
-                sprintf(name, core_info, i, "physical_package_id");
+                sprintf(name, core_info, cpu_override.mapping.cpu_count ? cpu_override.mapping.host_cpu_id[i] : i,
+                        "physical_package_id");
+
                 f = fopen(name, "r");
                 if (f)
                 {
@@ -881,6 +982,7 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
                     fclose(f);
                 }
                 else r = 0;
+
                 if (!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorPackage, r, (ULONG_PTR)1 << i))
                 {
                     fclose(fcpu_list);
@@ -903,21 +1005,36 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
             {
                 /* Mask of logical threads sharing same physical core in kernel core numbering. */
                 sprintf(name, core_info, i, "thread_siblings");
-                if(fake_logical_cpus_as_cores || !sysfs_parse_bitmap(name, &thread_mask)) thread_mask = (ULONG_PTR)1<<i;
+
+                if (cpu_override.mapping.cpu_count)
+                {
+                    thread_mask = cpu_override.smt ? (ULONG_PTR)0x3 << (i & ~1) : (ULONG_PTR)1 << i;
+                }
+                else
+                {
+                    if(fake_logical_cpus_as_cores || !sysfs_parse_bitmap(name, &thread_mask)) thread_mask = (ULONG_PTR)1<<i;
+                }
 
                 /* Needed later for NumaNode and Group. */
                 all_cpus_mask |= thread_mask;
 
                 if (relation == RelationAll || relation == RelationProcessorCore)
                 {
-                    sprintf(name, core_info, i, "thread_siblings_list");
-                    f = fake_logical_cpus_as_cores ? NULL : fopen(name, "r");
-                    if (f)
+                    if (cpu_override.mapping.cpu_count)
                     {
-                        fscanf(f, "%d%c", &phys_core, &op);
-                        fclose(f);
+                        phys_core = cpu_override.smt ? i / 2 : i;
+                    }
+                    else
+                    {
+                        sprintf(name, core_info, i, "thread_siblings_list");
+                        f = fake_logical_cpus_as_cores ? NULL : fopen(name, "r");
+                        if (f)
+                        {
+                            fscanf(f, "%d%c", &phys_core, &op);
+                            fclose(f);
+                        }
+                        else phys_core = i;
                     }
-                    else phys_core = i;
 
                     if (!logical_proc_info_add_by_id(data, dataex, &len, max_len, RelationProcessorCore, phys_core, thread_mask))
                     {
@@ -929,36 +1046,40 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
 
             if (relation == RelationAll || relation == RelationCache)
             {
+                unsigned int cpu_id;
+
+                cpu_id = cpu_override.mapping.cpu_count ? cpu_override.mapping.host_cpu_id[i] : i;
+
                 for(j = 0; j < 4; j++)
                 {
                     CACHE_DESCRIPTOR cache;
                     ULONG_PTR mask = 0;
 
-                    sprintf(name, cache_info, i, j, "shared_cpu_map");
+                    sprintf(name, cache_info, cpu_id, j, "shared_cpu_map");
                     if(!sysfs_parse_bitmap(name, &mask)) continue;
 
-                    sprintf(name, cache_info, i, j, "level");
+                    sprintf(name, cache_info, cpu_id, j, "level");
                     f = fopen(name, "r");
                     if(!f) continue;
                     fscanf(f, "%u", &r);
                     fclose(f);
                     cache.Level = r;
 
-                    sprintf(name, cache_info, i, j, "ways_of_associativity");
+                    sprintf(name, cache_info, cpu_id, j, "ways_of_associativity");
                     f = fopen(name, "r");
                     if(!f) continue;
                     fscanf(f, "%u", &r);
                     fclose(f);
                     cache.Associativity = r;
 
-                    sprintf(name, cache_info, i, j, "coherency_line_size");
+                    sprintf(name, cache_info, cpu_id, j, "coherency_line_size");
                     f = fopen(name, "r");
                     if(!f) continue;
                     fscanf(f, "%u", &r);
                     fclose(f);
                     cache.LineSize = r;
 
-                    sprintf(name, cache_info, i, j, "size");
+                    sprintf(name, cache_info, cpu_id, j, "size");
                     f = fopen(name, "r");
                     if(!f) continue;
                     fscanf(f, "%u%c", &r, &op);
@@ -967,7 +1088,7 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
                         WARN("unknown cache size %u%c\n", r, op);
                     cache.Size = (op=='K' ? r*1024 : r);
 
-                    sprintf(name, cache_info, i, j, "type");
+                    sprintf(name, cache_info, cpu_id, j, "type");
                     f = fopen(name, "r");
                     if(!f) continue;
                     fscanf(f, "%s", name);
@@ -979,6 +1100,19 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
                     else
                         cache.Type = CacheUnified;
 
+                    if (cpu_override.mapping.cpu_count)
+                    {
+                        ULONG_PTR host_mask = mask;
+                        unsigned int id;
+
+                        mask = 0;
+                        for (id = 0; id < cpu_override.mapping.cpu_count; ++id)
+                            if (host_mask & ((ULONG_PTR)1 << cpu_override.mapping.host_cpu_id[id]))
+                                mask |= (ULONG_PTR)1 << id;
+
+                        assert(mask);
+                    }
+
                     if (!logical_proc_info_add_cache(data, dataex, &len, max_len, mask, &cache))
                     {
                         fclose(fcpu_list);
@@ -987,6 +1121,9 @@ static NTSTATUS create_logical_proc_info( SYSTEM_LOGICAL_PROCESSOR_INFORMATION *
                 }
             }
         }
+
+        if (cpu_override.mapping.cpu_count)
+            break;
     }
     fclose(fcpu_list);
 
diff --git a/dlls/ntdll/unix/thread.c b/dlls/ntdll/unix/thread.c
index ca5dac43bb0..bc6a5451611 100644
--- a/dlls/ntdll/unix/thread.c
+++ b/dlls/ntdll/unix/thread.c
@@ -1323,7 +1323,20 @@ ULONG WINAPI NtGetCurrentProcessorNumber(void)
 
 #if defined(__linux__) && defined(__NR_getcpu)
     int res = syscall(__NR_getcpu, &processor, NULL, NULL);
-    if (res != -1) return processor;
+    if (res != -1)
+    {
+        struct cpu_topology_override *override = get_cpu_topology_override();
+        unsigned int i;
+
+        if (!override)
+            return processor;
+
+        for (i = 0; i < override->cpu_count; ++i)
+            if (override->host_cpu_id[i] == processor)
+                return i;
+
+        WARN("Thread is running on processor which is not in the defined override.\n");
+    }
 #endif
 
     if (NtCurrentTeb()->Peb->NumberOfProcessors > 1)
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index a3a418cfaa5..8edd529afd8 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -247,6 +247,7 @@ extern NTSTATUS open_unix_file( HANDLE *handle, const char *unix_name, ACCESS_MA
                                 ULONG options, void *ea_buffer, ULONG ea_length ) DECLSPEC_HIDDEN;
 extern void init_files(void) DECLSPEC_HIDDEN;
 extern void init_cpu_info(void) DECLSPEC_HIDDEN;
+extern struct cpu_topology_override *get_cpu_topology_override(void) DECLSPEC_HIDDEN;
 
 extern void dbg_init(void) DECLSPEC_HIDDEN;
 
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index f4f45d958be..aed7090572b 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -794,6 +794,12 @@ typedef struct
     lparam_t info;
 } cursor_pos_t;
 
+struct cpu_topology_override
+{
+    unsigned int cpu_count;
+    unsigned char host_cpu_id[64];
+};
+
 
 
 
@@ -895,6 +901,7 @@ struct init_process_done_request
     mod_handle_t module;
     client_ptr_t ldt_copy;
     client_ptr_t entry;
+    /* VARARG(cpu_override,cpu_topology_override); */
 };
 struct init_process_done_reply
 {
diff --git a/server/process.c b/server/process.c
index 97e074a5261..d1f9ab764f7 100644
--- a/server/process.c
+++ b/server/process.c
@@ -73,6 +73,7 @@ static void process_destroy( struct object *obj );
 static int process_get_esync_fd( struct object *obj, enum esync_type *type );
 static unsigned int process_get_fsync_idx( struct object *obj, enum fsync_type *type );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
+static void set_process_affinity( struct process *process, affinity_t affinity );
 
 static const struct object_ops process_ops =
 {
@@ -550,6 +551,7 @@ struct process *create_process( int fd, struct process *parent, int inherit_all,
     process->rawinput_kbd    = NULL;
     process->esync_fd        = -1;
     process->fsync_idx       = 0;
+    process->cpu_override.cpu_count = 0;
     list_init( &process->kernel_object );
     list_init( &process->thread_list );
     list_init( &process->locks );
@@ -1368,6 +1370,8 @@ DECL_HANDLER(init_process_done)
 {
     struct process_dll *dll;
     struct process *process = current->process;
+    const struct cpu_topology_override *cpu_override = get_req_data();
+    unsigned int have_cpu_override = get_req_data_size() / sizeof(*cpu_override);
 
     if (is_process_init_done(process))
     {
@@ -1397,6 +1401,9 @@ DECL_HANDLER(init_process_done)
     if (req->gui) process->idle_event = create_event( NULL, NULL, 0, 1, 0, NULL );
     if (process->debugger) set_process_debug_flag( process, 1 );
     reply->suspend = (current->suspend || process->suspend);
+
+    if (have_cpu_override)
+        process->cpu_override = *cpu_override;
 }
 
 /* open a handle to a process */
diff --git a/server/process.h b/server/process.h
index 430fd365508..d1b8b3fc222 100644
--- a/server/process.h
+++ b/server/process.h
@@ -100,6 +100,7 @@ struct process
     struct list          kernel_object;   /* list of kernel object pointers */
     int                  esync_fd;        /* esync file descriptor (signaled on exit) */
     unsigned int         fsync_idx;
+    struct cpu_topology_override cpu_override; /* Overridden CPUs to host CPUs mapping. */
 };
 
 #define CPU_FLAG(cpu) (1 << (cpu))
diff --git a/server/protocol.def b/server/protocol.def
index 48f9f4fae90..0f2fe077b80 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -810,6 +810,12 @@ typedef struct
     lparam_t info;
 } cursor_pos_t;
 
+struct cpu_topology_override
+{
+    unsigned int cpu_count;
+    unsigned char host_cpu_id[64];
+};
+
 /****************************************************************/
 /* Request declarations */
 
@@ -877,6 +883,7 @@ typedef struct
     mod_handle_t module;       /* main module base address */
     client_ptr_t ldt_copy;     /* address of LDT copy (in thread address space) */
     client_ptr_t entry;        /* process entry point */
+    VARARG(cpu_override,cpu_topology_override); /* Overridden CPUs to host CPUs mapping. */
 @REPLY
     int          suspend;      /* is process suspended? */
 @END
diff --git a/server/thread.c b/server/thread.c
index 0fb3aa0e727..31043c3df33 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -605,8 +605,19 @@ int set_thread_affinity( struct thread *thread, affinity_t affinity )
 
         CPU_ZERO( &set );
         for (i = 0, mask = 1; mask; i++, mask <<= 1)
-            if (affinity & mask) CPU_SET( i, &set );
-
+            if (affinity & mask)
+            {
+                if (thread->process->cpu_override.cpu_count)
+                {
+                    if (i >= thread->process->cpu_override.cpu_count)
+                        break;
+                    CPU_SET( thread->process->cpu_override.host_cpu_id[i], &set );
+                }
+                else
+                {
+                    CPU_SET( i, &set );
+                }
+            }
         ret = sched_setaffinity( thread->unix_tid, sizeof(set), &set );
     }
 #endif
@@ -1500,7 +1511,7 @@ DECL_HANDLER(init_thread)
         reply->info_size  = init_process( current );
         if (!process->parent_id)
             process->affinity = current->affinity = get_thread_affinity( current );
-        else
+        else if (!process->cpu_override.cpu_count)
             set_thread_affinity( current, current->affinity );
     }
     else
@@ -1514,7 +1525,8 @@ DECL_HANDLER(init_thread)
             process->unix_pid = -1;  /* can happen with linuxthreads */
         init_thread_context( current );
         generate_debug_event( current, CREATE_THREAD_DEBUG_EVENT, &req->entry );
-        set_thread_affinity( current, current->affinity );
+        if (!process->cpu_override.cpu_count)
+            set_thread_affinity( current, current->affinity );
     }
     debug_level = max( debug_level, req->debug_level );
 
diff --git a/server/trace.c b/server/trace.c
index e3a29beb6da..7df5681357b 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1293,6 +1293,24 @@ static void dump_varargs_handle_infos( const char *prefix, data_size_t size )
     fputc( '}', stderr );
 }
 
+static void dump_varargs_cpu_topology_override( const char *prefix, data_size_t size )
+{
+    const struct cpu_topology_override *cpu_topology = cur_data;
+    unsigned int i;
+
+    if (size < sizeof(*cpu_topology))
+        return;
+
+    fprintf( stderr,"%s{", prefix );
+    for (i = 0; i < cpu_topology->cpu_count; ++i)
+    {
+        if (i) fputc( ',', stderr );
+        fprintf( stderr, "%u", cpu_topology->host_cpu_id[i] );
+    }
+    fputc( '}', stderr );
+    remove_data( size );
+}
+
 typedef void (*dump_func)( const void *req );
 
 /* Everything below this line is generated automatically by tools/make_requests */
@@ -1369,6 +1387,7 @@ static void dump_init_process_done_request( const struct init_process_done_reque
     dump_uint64( ", module=", &req->module );
     dump_uint64( ", ldt_copy=", &req->ldt_copy );
     dump_uint64( ", entry=", &req->entry );
+    dump_varargs_cpu_topology_override( ", cpu_override=", cur_size );
 }
 
 static void dump_init_process_done_reply( const struct init_process_done_reply *req )
  
From 2452b57e7fed9ac5036df9bcace5c28366a8eb41 Mon Sep 17 00:00:00 2001
From: Andrew Eikum <aeikum@codeweavers.com>
Date: Fri, 8 Jan 2021 13:47:39 -0600
Subject: [PATCH] HACK: kernelbase: Add NFS EXE to Origin file blacklist hack

---
 dlls/kernelbase/file.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/kernelbase/file.c b/dlls/kernelbase/file.c
index a33440107b6..397aa64dce2 100644
--- a/dlls/kernelbase/file.c
+++ b/dlls/kernelbase/file.c
@@ -741,7 +741,8 @@ static BOOL CALLBACK init_file_blacklist(PINIT_ONCE init_once, PVOID parameter,
             L"igoproxy64.exe",
             L"igoproxy.exe",
             L"origin.exe",
-            L"easteamproxy.exe"
+            L"easteamproxy.exe",
+            L"NFS11Remastered.exe"
         };
 
         WCHAR cur_exe[MAX_PATH];
From 4ddb4142cf134a1939d897c4cd6d3b96028b4ed4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 16:24:03 +0100
Subject: [PATCH] ntdll/tests: Test RtlRegisterWait with WT_EXECUTEINWAITTHREAD
 flag.

---
 dlls/ntdll/tests/threadpool.c | 91 ++++++++++++++++++++++++++++++++++-
 1 file changed, 90 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/tests/threadpool.c b/dlls/ntdll/tests/threadpool.c
index 24f32346fbe..b67654ef6a4 100644
--- a/dlls/ntdll/tests/threadpool.c
+++ b/dlls/ntdll/tests/threadpool.c
@@ -207,7 +207,7 @@ static void test_RtlRegisterWait(void)
     struct rtl_wait_info info;
     HANDLE semaphores[2];
     NTSTATUS status;
-    DWORD result;
+    DWORD result, threadid;
 
     semaphores[0] = CreateSemaphoreW(NULL, 0, 2, NULL);
     ok(semaphores[0] != NULL, "failed to create semaphore\n");
@@ -298,6 +298,69 @@ static void test_RtlRegisterWait(void)
     status = RtlDeregisterWait(wait1);
     ok(!status, "RtlDeregisterWait failed with status %x\n", status);
 
+    /* test RtlRegisterWait WT_EXECUTEINWAITTHREAD flag */
+    info.userdata = 0;
+    info.threadid = 0;
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, 200, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    result = WaitForSingleObject(semaphores[0], 200);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
+    ok(info.threadid && info.threadid != GetCurrentThreadId(), "unexpected wait thread id %x\n", info.threadid);
+    threadid = info.threadid;
+    result = WaitForSingleObject(semaphores[1], 0);
+    ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
+    Sleep(50);
+    status = RtlDeregisterWait(wait1);
+    ok(!status, "RtlDeregisterWait failed with status %x\n", status);
+
+    info.userdata = 0;
+    info.threadid = 0;
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, 200, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    result = WaitForSingleObject(semaphores[0], 200);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
+    todo_wine ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
+    result = WaitForSingleObject(semaphores[1], 0);
+    ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
+    Sleep(50);
+    status = RtlDeregisterWait(wait1);
+    ok(!status, "RtlDeregisterWait failed with status %x\n", status);
+
+    /* test RtlRegisterWait WT_EXECUTEINWAITTHREAD flag with 0 timeout */
+    info.userdata = 0;
+    info.threadid = 0;
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, 0, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    result = WaitForSingleObject(semaphores[0], 100);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 0x10000, "expected info.userdata = 0x10000, got %u\n", info.userdata);
+    ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
+    result = WaitForSingleObject(semaphores[1], 0);
+    ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
+    Sleep(50);
+    status = RtlDeregisterWait(wait1);
+    ok(!status, "RtlDeregisterWait failed with status %x\n", status);
+
+    /* test RtlRegisterWait WT_EXECUTEINWAITTHREAD flag with already signaled event */
+    info.userdata = 0;
+    info.threadid = 0;
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, 200, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    result = WaitForSingleObject(semaphores[0], 200);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
+    todo_wine ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
+    result = WaitForSingleObject(semaphores[1], 0);
+    ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
+    Sleep(50);
+    status = RtlDeregisterWait(wait1);
+    ok(!status, "RtlDeregisterWait failed with status %x\n", status);
+
     /* test for IO threads */
     info.userdata = 0;
     info.threadid = 0;
@@ -431,6 +494,19 @@ static void test_RtlRegisterWait(void)
     result = WaitForSingleObject(semaphores[0], 1000);
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
 
+    info.userdata = 0;
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, INFINITE, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
+    status = RtlDeregisterWait(wait1);
+    ok(status == STATUS_PENDING, "expected STATUS_PENDING, got %x\n", status);
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+
     info.userdata = 0;
     status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, INFINITE, WT_EXECUTEONLYONCE);
     ok(!status, "RtlRegisterWait failed with status %x\n", status);
@@ -457,6 +533,19 @@ static void test_RtlRegisterWait(void)
     result = WaitForSingleObject(semaphores[0], 0);
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
 
+    info.wait_result = WAIT_TIMEOUT;
+    info.userdata = 0;
+    status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, INFINITE, WT_EXECUTEINWAITTHREAD|WT_EXECUTEONLYONCE);
+    ok(!status, "RtlRegisterWait failed with status %x\n", status);
+    ReleaseSemaphore(semaphores[1], 1, NULL);
+    result = WaitForSingleObject(semaphores[0], 1000);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+    ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
+    status = RtlDeregisterWaitEx(wait1, INVALID_HANDLE_VALUE);
+    ok(!status, "RtlDeregisterWaitEx failed with status %x\n", status);
+    result = WaitForSingleObject(semaphores[0], 0);
+    ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
+
     info.wait_result = WAIT_OBJECT_0;
     info.userdata = 0;
     status = RtlRegisterWait(&wait1, semaphores[1], rtl_wait_cb, &info, INFINITE, WT_EXECUTEONLYONCE);
From fc4156fc790d076577e189188f51d90c5aa05890 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 14:18:10 +0100
Subject: [PATCH] ntdll: Move Rtl(Un)RegisterWait code below threadpool
 structs.

---
 dlls/ntdll/threadpool.c | 432 ++++++++++++++++++++--------------------
 1 file changed, 216 insertions(+), 216 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 1d64bd82bf4..db645118059 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -553,222 +553,6 @@ static inline PLARGE_INTEGER get_nt_timeout( PLARGE_INTEGER pTime, ULONG timeout
     return pTime;
 }
 
-static void delete_wait_work_item(struct wait_work_item *wait_work_item)
-{
-    NtClose( wait_work_item->CancelEvent );
-    RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
-}
-
-static DWORD CALLBACK wait_thread_proc(LPVOID Arg)
-{
-    struct wait_work_item *wait_work_item = Arg;
-    NTSTATUS status;
-    BOOLEAN alertable = (wait_work_item->Flags & WT_EXECUTEINIOTHREAD) != 0;
-    HANDLE handles[2] = { wait_work_item->Object, wait_work_item->CancelEvent };
-    LARGE_INTEGER timeout;
-    HANDLE completion_event;
-
-    TRACE("\n");
-
-    while (TRUE)
-    {
-        status = NtWaitForMultipleObjects( 2, handles, TRUE, alertable,
-                                           get_nt_timeout( &timeout, wait_work_item->Milliseconds ) );
-        if (status == STATUS_WAIT_0 || status == STATUS_TIMEOUT)
-        {
-            BOOLEAN TimerOrWaitFired;
-
-            if (status == STATUS_WAIT_0)
-            {
-                TRACE( "object %p signaled, calling callback %p with context %p\n",
-                    wait_work_item->Object, wait_work_item->Callback,
-                    wait_work_item->Context );
-                TimerOrWaitFired = FALSE;
-            }
-            else
-            {
-                TRACE( "wait for object %p timed out, calling callback %p with context %p\n",
-                    wait_work_item->Object, wait_work_item->Callback,
-                    wait_work_item->Context );
-                TimerOrWaitFired = TRUE;
-            }
-            InterlockedExchange( &wait_work_item->CallbackInProgress, TRUE );
-            if (wait_work_item->CompletionEvent)
-            {
-                TRACE( "Work has been canceled.\n" );
-                break;
-            }
-            wait_work_item->Callback( wait_work_item->Context, TimerOrWaitFired );
-            InterlockedExchange( &wait_work_item->CallbackInProgress, FALSE );
-
-            if (wait_work_item->Flags & WT_EXECUTEONLYONCE)
-                break;
-        }
-        else if (status != STATUS_USER_APC)
-            break;
-    }
-
-
-    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
-    {
-        completion_event = wait_work_item->CompletionEvent;
-        delete_wait_work_item( wait_work_item );
-        if (completion_event && completion_event != INVALID_HANDLE_VALUE)
-            NtSetEvent( completion_event, NULL );
-    }
-
-    return 0;
-}
-
-/***********************************************************************
- *              RtlRegisterWait   (NTDLL.@)
- *
- * Registers a wait for a handle to become signaled.
- *
- * PARAMS
- *  NewWaitObject [I] Handle to the new wait object. Use RtlDeregisterWait() to free it.
- *  Object   [I] Object to wait to become signaled.
- *  Callback [I] Callback function to execute when the wait times out or the handle is signaled.
- *  Context  [I] Context to pass to the callback function when it is executed.
- *  Milliseconds [I] Number of milliseconds to wait before timing out.
- *  Flags    [I] Flags. See notes.
- *
- * RETURNS
- *  Success: STATUS_SUCCESS.
- *  Failure: Any NTSTATUS code.
- *
- * NOTES
- *  Flags can be one or more of the following:
- *|WT_EXECUTEDEFAULT - Executes the work item in a non-I/O worker thread.
- *|WT_EXECUTEINIOTHREAD - Executes the work item in an I/O worker thread.
- *|WT_EXECUTEINPERSISTENTTHREAD - Executes the work item in a thread that is persistent.
- *|WT_EXECUTELONGFUNCTION - Hints that the execution can take a long time.
- *|WT_TRANSFER_IMPERSONATION - Executes the function with the current access token.
- */
-NTSTATUS WINAPI RtlRegisterWait(PHANDLE NewWaitObject, HANDLE Object,
-                                RTL_WAITORTIMERCALLBACKFUNC Callback,
-                                PVOID Context, ULONG Milliseconds, ULONG Flags)
-{
-    struct wait_work_item *wait_work_item;
-    NTSTATUS status;
-
-    TRACE( "(%p, %p, %p, %p, %d, 0x%x)\n", NewWaitObject, Object, Callback, Context, Milliseconds, Flags );
-
-    wait_work_item = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*wait_work_item) );
-    if (!wait_work_item)
-        return STATUS_NO_MEMORY;
-
-    wait_work_item->Object = Object;
-    wait_work_item->Callback = Callback;
-    wait_work_item->Context = Context;
-    wait_work_item->Milliseconds = Milliseconds;
-    wait_work_item->Flags = Flags;
-    wait_work_item->CallbackInProgress = FALSE;
-    wait_work_item->DeleteCount = 0;
-    wait_work_item->CompletionEvent = NULL;
-
-    status = NtCreateEvent( &wait_work_item->CancelEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
-    if (status != STATUS_SUCCESS)
-    {
-        RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
-        return status;
-    }
-
-    Flags = Flags & (WT_EXECUTEINIOTHREAD | WT_EXECUTEINPERSISTENTTHREAD |
-                     WT_EXECUTELONGFUNCTION | WT_TRANSFER_IMPERSONATION);
-    status = RtlQueueWorkItem( wait_thread_proc, wait_work_item, Flags );
-    if (status != STATUS_SUCCESS)
-    {
-        delete_wait_work_item( wait_work_item );
-        return status;
-    }
-
-    *NewWaitObject = wait_work_item;
-    return status;
-}
-
-/***********************************************************************
- *              RtlDeregisterWaitEx   (NTDLL.@)
- *
- * Cancels a wait operation and frees the resources associated with calling
- * RtlRegisterWait().
- *
- * PARAMS
- *  WaitObject [I] Handle to the wait object to free.
- *
- * RETURNS
- *  Success: STATUS_SUCCESS.
- *  Failure: Any NTSTATUS code.
- */
-NTSTATUS WINAPI RtlDeregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
-{
-    struct wait_work_item *wait_work_item = WaitHandle;
-    NTSTATUS status;
-    HANDLE LocalEvent = NULL;
-    int CallbackInProgress;
-
-    TRACE( "(%p %p)\n", WaitHandle, CompletionEvent );
-
-    if (WaitHandle == NULL)
-        return STATUS_INVALID_HANDLE;
-
-    InterlockedExchangePointer( &wait_work_item->CompletionEvent, INVALID_HANDLE_VALUE );
-    CallbackInProgress = wait_work_item->CallbackInProgress;
-    TRACE( "callback in progress %u\n", CallbackInProgress );
-    if (CompletionEvent == INVALID_HANDLE_VALUE || !CallbackInProgress)
-    {
-        status = NtCreateEvent( &LocalEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
-        if (status != STATUS_SUCCESS)
-            return status;
-        InterlockedExchangePointer( &wait_work_item->CompletionEvent, LocalEvent );
-    }
-    else if (CompletionEvent != NULL)
-    {
-        InterlockedExchangePointer( &wait_work_item->CompletionEvent, CompletionEvent );
-    }
-
-    NtSetEvent( wait_work_item->CancelEvent, NULL );
-
-    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
-    {
-        status = STATUS_SUCCESS;
-        delete_wait_work_item( wait_work_item );
-    }
-    else if (LocalEvent)
-    {
-        TRACE( "Waiting for completion event\n" );
-        NtWaitForSingleObject( LocalEvent, FALSE, NULL );
-        status = STATUS_SUCCESS;
-    }
-    else
-    {
-        status = STATUS_PENDING;
-    }
-
-    if (LocalEvent)
-        NtClose( LocalEvent );
-
-    return status;
-}
-
-/***********************************************************************
- *              RtlDeregisterWait   (NTDLL.@)
- *
- * Cancels a wait operation and frees the resources associated with calling
- * RtlRegisterWait().
- *
- * PARAMS
- *  WaitObject [I] Handle to the wait object to free.
- *
- * RETURNS
- *  Success: STATUS_SUCCESS.
- *  Failure: Any NTSTATUS code.
- */
-NTSTATUS WINAPI RtlDeregisterWait(HANDLE WaitHandle)
-{
-    return RtlDeregisterWaitEx(WaitHandle, NULL);
-}
-
 
 /************************** Timer Queue Impl **************************/
 
@@ -3350,3 +3134,219 @@ NTSTATUS WINAPI TpQueryPoolStackInformation( TP_POOL *pool, TP_POOL_STACK_INFORM
 
     return STATUS_SUCCESS;
 }
+
+static void delete_wait_work_item(struct wait_work_item *wait_work_item)
+{
+    NtClose( wait_work_item->CancelEvent );
+    RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
+}
+
+static DWORD CALLBACK wait_thread_proc(LPVOID Arg)
+{
+    struct wait_work_item *wait_work_item = Arg;
+    NTSTATUS status;
+    BOOLEAN alertable = (wait_work_item->Flags & WT_EXECUTEINIOTHREAD) != 0;
+    HANDLE handles[2] = { wait_work_item->Object, wait_work_item->CancelEvent };
+    LARGE_INTEGER timeout;
+    HANDLE completion_event;
+
+    TRACE("\n");
+
+    while (TRUE)
+    {
+        status = NtWaitForMultipleObjects( 2, handles, TRUE, alertable,
+                                           get_nt_timeout( &timeout, wait_work_item->Milliseconds ) );
+        if (status == STATUS_WAIT_0 || status == STATUS_TIMEOUT)
+        {
+            BOOLEAN TimerOrWaitFired;
+
+            if (status == STATUS_WAIT_0)
+            {
+                TRACE( "object %p signaled, calling callback %p with context %p\n",
+                    wait_work_item->Object, wait_work_item->Callback,
+                    wait_work_item->Context );
+                TimerOrWaitFired = FALSE;
+            }
+            else
+            {
+                TRACE( "wait for object %p timed out, calling callback %p with context %p\n",
+                    wait_work_item->Object, wait_work_item->Callback,
+                    wait_work_item->Context );
+                TimerOrWaitFired = TRUE;
+            }
+            InterlockedExchange( &wait_work_item->CallbackInProgress, TRUE );
+            if (wait_work_item->CompletionEvent)
+            {
+                TRACE( "Work has been canceled.\n" );
+                break;
+            }
+            wait_work_item->Callback( wait_work_item->Context, TimerOrWaitFired );
+            InterlockedExchange( &wait_work_item->CallbackInProgress, FALSE );
+
+            if (wait_work_item->Flags & WT_EXECUTEONLYONCE)
+                break;
+        }
+        else if (status != STATUS_USER_APC)
+            break;
+    }
+
+
+    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
+    {
+        completion_event = wait_work_item->CompletionEvent;
+        delete_wait_work_item( wait_work_item );
+        if (completion_event && completion_event != INVALID_HANDLE_VALUE)
+            NtSetEvent( completion_event, NULL );
+    }
+
+    return 0;
+}
+
+/***********************************************************************
+ *              RtlRegisterWait   (NTDLL.@)
+ *
+ * Registers a wait for a handle to become signaled.
+ *
+ * PARAMS
+ *  NewWaitObject [I] Handle to the new wait object. Use RtlDeregisterWait() to free it.
+ *  Object   [I] Object to wait to become signaled.
+ *  Callback [I] Callback function to execute when the wait times out or the handle is signaled.
+ *  Context  [I] Context to pass to the callback function when it is executed.
+ *  Milliseconds [I] Number of milliseconds to wait before timing out.
+ *  Flags    [I] Flags. See notes.
+ *
+ * RETURNS
+ *  Success: STATUS_SUCCESS.
+ *  Failure: Any NTSTATUS code.
+ *
+ * NOTES
+ *  Flags can be one or more of the following:
+ *|WT_EXECUTEDEFAULT - Executes the work item in a non-I/O worker thread.
+ *|WT_EXECUTEINIOTHREAD - Executes the work item in an I/O worker thread.
+ *|WT_EXECUTEINPERSISTENTTHREAD - Executes the work item in a thread that is persistent.
+ *|WT_EXECUTELONGFUNCTION - Hints that the execution can take a long time.
+ *|WT_TRANSFER_IMPERSONATION - Executes the function with the current access token.
+ */
+NTSTATUS WINAPI RtlRegisterWait(PHANDLE NewWaitObject, HANDLE Object,
+                                RTL_WAITORTIMERCALLBACKFUNC Callback,
+                                PVOID Context, ULONG Milliseconds, ULONG Flags)
+{
+    struct wait_work_item *wait_work_item;
+    NTSTATUS status;
+
+    TRACE( "(%p, %p, %p, %p, %d, 0x%x)\n", NewWaitObject, Object, Callback, Context, Milliseconds, Flags );
+
+    wait_work_item = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*wait_work_item) );
+    if (!wait_work_item)
+        return STATUS_NO_MEMORY;
+
+    wait_work_item->Object = Object;
+    wait_work_item->Callback = Callback;
+    wait_work_item->Context = Context;
+    wait_work_item->Milliseconds = Milliseconds;
+    wait_work_item->Flags = Flags;
+    wait_work_item->CallbackInProgress = FALSE;
+    wait_work_item->DeleteCount = 0;
+    wait_work_item->CompletionEvent = NULL;
+
+    status = NtCreateEvent( &wait_work_item->CancelEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
+    if (status != STATUS_SUCCESS)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
+        return status;
+    }
+
+    Flags = Flags & (WT_EXECUTEINIOTHREAD | WT_EXECUTEINPERSISTENTTHREAD |
+                     WT_EXECUTELONGFUNCTION | WT_TRANSFER_IMPERSONATION);
+    status = RtlQueueWorkItem( wait_thread_proc, wait_work_item, Flags );
+    if (status != STATUS_SUCCESS)
+    {
+        delete_wait_work_item( wait_work_item );
+        return status;
+    }
+
+    *NewWaitObject = wait_work_item;
+    return status;
+}
+
+/***********************************************************************
+ *              RtlDeregisterWaitEx   (NTDLL.@)
+ *
+ * Cancels a wait operation and frees the resources associated with calling
+ * RtlRegisterWait().
+ *
+ * PARAMS
+ *  WaitObject [I] Handle to the wait object to free.
+ *
+ * RETURNS
+ *  Success: STATUS_SUCCESS.
+ *  Failure: Any NTSTATUS code.
+ */
+NTSTATUS WINAPI RtlDeregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
+{
+    struct wait_work_item *wait_work_item = WaitHandle;
+    NTSTATUS status;
+    HANDLE LocalEvent = NULL;
+    int CallbackInProgress;
+
+    TRACE( "(%p %p)\n", WaitHandle, CompletionEvent );
+
+    if (WaitHandle == NULL)
+        return STATUS_INVALID_HANDLE;
+
+    InterlockedExchangePointer( &wait_work_item->CompletionEvent, INVALID_HANDLE_VALUE );
+    CallbackInProgress = wait_work_item->CallbackInProgress;
+    TRACE( "callback in progress %u\n", CallbackInProgress );
+    if (CompletionEvent == INVALID_HANDLE_VALUE || !CallbackInProgress)
+    {
+        status = NtCreateEvent( &LocalEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
+        if (status != STATUS_SUCCESS)
+            return status;
+        InterlockedExchangePointer( &wait_work_item->CompletionEvent, LocalEvent );
+    }
+    else if (CompletionEvent != NULL)
+    {
+        InterlockedExchangePointer( &wait_work_item->CompletionEvent, CompletionEvent );
+    }
+
+    NtSetEvent( wait_work_item->CancelEvent, NULL );
+
+    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
+    {
+        status = STATUS_SUCCESS;
+        delete_wait_work_item( wait_work_item );
+    }
+    else if (LocalEvent)
+    {
+        TRACE( "Waiting for completion event\n" );
+        NtWaitForSingleObject( LocalEvent, FALSE, NULL );
+        status = STATUS_SUCCESS;
+    }
+    else
+    {
+        status = STATUS_PENDING;
+    }
+
+    if (LocalEvent)
+        NtClose( LocalEvent );
+
+    return status;
+}
+
+/***********************************************************************
+ *              RtlDeregisterWait   (NTDLL.@)
+ *
+ * Cancels a wait operation and frees the resources associated with calling
+ * RtlRegisterWait().
+ *
+ * PARAMS
+ *  WaitObject [I] Handle to the wait object to free.
+ *
+ * RETURNS
+ *  Success: STATUS_SUCCESS.
+ *  Failure: Any NTSTATUS code.
+ */
+NTSTATUS WINAPI RtlDeregisterWait(HANDLE WaitHandle)
+{
+    return RtlDeregisterWaitEx(WaitHandle, NULL);
+}
From 5a90ad68900fc12ff470ea664c09e2a791457c7a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 16:48:51 +0100
Subject: [PATCH] ntdll: Don't force submit wait in TpSetWait if timeout is 0.

It'll be submitted eventually, no need to force it and it makes support
for WT_EXECUTEINWAITTHREAD flag harder.
---
 dlls/ntdll/threadpool.c | 9 ---------
 1 file changed, 9 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index db645118059..bef9a11905e 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -2941,7 +2941,6 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
 {
     struct threadpool_object *this = impl_from_TP_WAIT( wait );
     ULONGLONG timestamp = TIMEOUT_INFINITE;
-    BOOL submit_wait = FALSE;
 
     TRACE( "%p %p %p\n", wait, handle, timeout );
 
@@ -2965,11 +2964,6 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
                 NtQuerySystemTime( &now );
                 timestamp = now.QuadPart - timestamp;
             }
-            else if (!timestamp)
-            {
-                submit_wait = TRUE;
-                handle = NULL;
-            }
         }
 
         /* Add wait object back into one of the queues. */
@@ -2990,9 +2984,6 @@ VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
     }
 
     leave_critical_section( &waitqueue.cs );
-
-    if (submit_wait)
-        tp_object_submit( this, FALSE );
 }
 
 /***********************************************************************
From 6400e544fa6b917cb9d4e343a728756ab06d3125 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 23:06:25 +0100
Subject: [PATCH] ntdll: Introduce new tp_object_execute helper.

To execute a threadpool_object callbacks.
---
 dlls/ntdll/threadpool.c | 303 +++++++++++++++++++++-------------------
 1 file changed, 160 insertions(+), 143 deletions(-)

diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index bef9a11905e..e9ca32a3be7 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -372,6 +372,7 @@ static inline struct threadpool_instance *impl_from_TP_CALLBACK_INSTANCE( TP_CAL
 
 static void CALLBACK threadpool_worker_proc( void *param );
 static void tp_object_submit( struct threadpool_object *object, BOOL signaled );
+static void tp_object_execute( struct threadpool_object *object );
 static void tp_object_prepare_shutdown( struct threadpool_object *object );
 static BOOL tp_object_release( struct threadpool_object *object );
 static struct threadpool *default_threadpool = NULL;
@@ -2095,18 +2096,171 @@ static struct list *threadpool_get_next_item( const struct threadpool *pool )
 }
 
 /***********************************************************************
- *           threadpool_worker_proc    (internal)
+ *           tp_object_execute    (internal)
+ *
+ * Executes a threadpool object callback, object->pool->cs has to be
+ * held.
  */
-static void CALLBACK threadpool_worker_proc( void *param )
+static void tp_object_execute( struct threadpool_object *object )
 {
     TP_CALLBACK_INSTANCE *callback_instance;
     struct threadpool_instance instance;
     struct io_completion completion;
-    struct threadpool *pool = param;
+    struct threadpool *pool = object->pool;
     TP_WAIT_RESULT wait_result = 0;
+    NTSTATUS status;
+
+    object->num_pending_callbacks--;
+
+    /* For wait objects check if they were signaled or have timed out. */
+    if (object->type == TP_OBJECT_TYPE_WAIT)
+    {
+        wait_result = object->u.wait.signaled ? WAIT_OBJECT_0 : WAIT_TIMEOUT;
+        if (wait_result == WAIT_OBJECT_0) object->u.wait.signaled--;
+    }
+    else if (object->type == TP_OBJECT_TYPE_IO)
+    {
+        assert( object->u.io.completion_count );
+        completion = object->u.io.completions[--object->u.io.completion_count];
+        object->u.io.pending_count--;
+    }
+
+    /* Leave critical section and do the actual callback. */
+    object->num_associated_callbacks++;
+    object->num_running_callbacks++;
+    leave_critical_section( &pool->cs );
+
+    /* Initialize threadpool instance struct. */
+    callback_instance = (TP_CALLBACK_INSTANCE *)&instance;
+    instance.object                     = object;
+    instance.threadid                   = GetCurrentThreadId();
+    instance.associated                 = TRUE;
+    instance.may_run_long               = object->may_run_long;
+    instance.cleanup.critical_section   = NULL;
+    instance.cleanup.mutex              = NULL;
+    instance.cleanup.semaphore          = NULL;
+    instance.cleanup.semaphore_count    = 0;
+    instance.cleanup.event              = NULL;
+    instance.cleanup.library            = NULL;
+
+    switch (object->type)
+    {
+        case TP_OBJECT_TYPE_SIMPLE:
+        {
+            TRACE( "executing simple callback %p(%p, %p)\n",
+                   object->u.simple.callback, callback_instance, object->userdata );
+            object->u.simple.callback( callback_instance, object->userdata );
+            TRACE( "callback %p returned\n", object->u.simple.callback );
+            break;
+        }
+
+        case TP_OBJECT_TYPE_WORK:
+        {
+            TRACE( "executing work callback %p(%p, %p, %p)\n",
+                   object->u.work.callback, callback_instance, object->userdata, object );
+            object->u.work.callback( callback_instance, object->userdata, (TP_WORK *)object );
+            TRACE( "callback %p returned\n", object->u.work.callback );
+            break;
+        }
+
+        case TP_OBJECT_TYPE_TIMER:
+        {
+            TRACE( "executing timer callback %p(%p, %p, %p)\n",
+                   object->u.timer.callback, callback_instance, object->userdata, object );
+            object->u.timer.callback( callback_instance, object->userdata, (TP_TIMER *)object );
+            TRACE( "callback %p returned\n", object->u.timer.callback );
+            break;
+        }
+
+        case TP_OBJECT_TYPE_WAIT:
+        {
+            TRACE( "executing wait callback %p(%p, %p, %p, %u)\n",
+                   object->u.wait.callback, callback_instance, object->userdata, object, wait_result );
+            object->u.wait.callback( callback_instance, object->userdata, (TP_WAIT *)object, wait_result );
+            TRACE( "callback %p returned\n", object->u.wait.callback );
+            break;
+        }
+
+        case TP_OBJECT_TYPE_IO:
+        {
+            TRACE( "executing I/O callback %p(%p, %p, %#lx, %p, %p)\n",
+                    object->u.io.callback, callback_instance, object->userdata,
+                    completion.cvalue, &completion.iosb, (TP_IO *)object );
+            object->u.io.callback( callback_instance, object->userdata,
+                    (void *)completion.cvalue, &completion.iosb, (TP_IO *)object );
+            TRACE( "callback %p returned\n", object->u.io.callback );
+            break;
+        }
+
+        default:
+            assert(0);
+            break;
+    }
+
+    /* Execute finalization callback. */
+    if (object->finalization_callback)
+    {
+        TRACE( "executing finalization callback %p(%p, %p)\n",
+               object->finalization_callback, callback_instance, object->userdata );
+        object->finalization_callback( callback_instance, object->userdata );
+        TRACE( "callback %p returned\n", object->finalization_callback );
+    }
+
+    /* Execute cleanup tasks. */
+    if (instance.cleanup.critical_section)
+    {
+        RtlLeaveCriticalSection( instance.cleanup.critical_section );
+    }
+    if (instance.cleanup.mutex)
+    {
+        status = NtReleaseMutant( instance.cleanup.mutex, NULL );
+        if (status != STATUS_SUCCESS) goto skip_cleanup;
+    }
+    if (instance.cleanup.semaphore)
+    {
+        status = NtReleaseSemaphore( instance.cleanup.semaphore, instance.cleanup.semaphore_count, NULL );
+        if (status != STATUS_SUCCESS) goto skip_cleanup;
+    }
+    if (instance.cleanup.event)
+    {
+        status = NtSetEvent( instance.cleanup.event, NULL );
+        if (status != STATUS_SUCCESS) goto skip_cleanup;
+    }
+    if (instance.cleanup.library)
+    {
+        LdrUnloadDll( instance.cleanup.library );
+    }
+
+skip_cleanup:
+    enter_critical_section( &pool->cs );
+
+    /* Simple callbacks are automatically shutdown after execution. */
+    if (object->type == TP_OBJECT_TYPE_SIMPLE)
+    {
+        tp_object_prepare_shutdown( object );
+        object->shutdown = TRUE;
+    }
+
+    object->num_running_callbacks--;
+    if (object_is_finished( object, TRUE ))
+        RtlWakeAllConditionVariable( &object->group_finished_event );
+
+    if (instance.associated)
+    {
+        object->num_associated_callbacks--;
+        if (object_is_finished( object, FALSE ))
+            RtlWakeAllConditionVariable( &object->finished_event );
+    }
+}
+
+/***********************************************************************
+ *           threadpool_worker_proc    (internal)
+ */
+static void CALLBACK threadpool_worker_proc( void *param )
+{
+    struct threadpool *pool = param;
     LARGE_INTEGER timeout;
     struct list *ptr;
-    NTSTATUS status;
 
     TRACE( "starting worker thread for pool %p\n", pool );
 
@@ -2121,151 +2275,14 @@ static void CALLBACK threadpool_worker_proc( void *param )
             /* If further pending callbacks are queued, move the work item to
              * the end of the pool list. Otherwise remove it from the pool. */
             list_remove( &object->pool_entry );
-            if (--object->num_pending_callbacks)
+            if (object->num_pending_callbacks > 1)
                 tp_object_prio_queue( object );
 
-            /* For wait objects check if they were signaled or have timed out. */
-            if (object->type == TP_OBJECT_TYPE_WAIT)
-            {
-                wait_result = object->u.wait.signaled ? WAIT_OBJECT_0 : WAIT_TIMEOUT;
-                if (wait_result == WAIT_OBJECT_0) object->u.wait.signaled--;
-            }
-            else if (object->type == TP_OBJECT_TYPE_IO)
-            {
-                assert( object->u.io.completion_count );
-                completion = object->u.io.completions[--object->u.io.completion_count];
-                object->u.io.pending_count--;
-            }
+            tp_object_execute( object );
 
-            /* Leave critical section and do the actual callback. */
-            object->num_associated_callbacks++;
-            object->num_running_callbacks++;
-            leave_critical_section( &pool->cs );
-
-            /* Initialize threadpool instance struct. */
-            callback_instance = (TP_CALLBACK_INSTANCE *)&instance;
-            instance.object                     = object;
-            instance.threadid                   = GetCurrentThreadId();
-            instance.associated                 = TRUE;
-            instance.may_run_long               = object->may_run_long;
-            instance.cleanup.critical_section   = NULL;
-            instance.cleanup.mutex              = NULL;
-            instance.cleanup.semaphore          = NULL;
-            instance.cleanup.semaphore_count    = 0;
-            instance.cleanup.event              = NULL;
-            instance.cleanup.library            = NULL;
-
-            switch (object->type)
-            {
-                case TP_OBJECT_TYPE_SIMPLE:
-                {
-                    TRACE( "executing simple callback %p(%p, %p)\n",
-                           object->u.simple.callback, callback_instance, object->userdata );
-                    object->u.simple.callback( callback_instance, object->userdata );
-                    TRACE( "callback %p returned\n", object->u.simple.callback );
-                    break;
-                }
-
-                case TP_OBJECT_TYPE_WORK:
-                {
-                    TRACE( "executing work callback %p(%p, %p, %p)\n",
-                           object->u.work.callback, callback_instance, object->userdata, object );
-                    object->u.work.callback( callback_instance, object->userdata, (TP_WORK *)object );
-                    TRACE( "callback %p returned\n", object->u.work.callback );
-                    break;
-                }
-
-                case TP_OBJECT_TYPE_TIMER:
-                {
-                    TRACE( "executing timer callback %p(%p, %p, %p)\n",
-                           object->u.timer.callback, callback_instance, object->userdata, object );
-                    object->u.timer.callback( callback_instance, object->userdata, (TP_TIMER *)object );
-                    TRACE( "callback %p returned\n", object->u.timer.callback );
-                    break;
-                }
-
-                case TP_OBJECT_TYPE_WAIT:
-                {
-                    TRACE( "executing wait callback %p(%p, %p, %p, %u)\n",
-                           object->u.wait.callback, callback_instance, object->userdata, object, wait_result );
-                    object->u.wait.callback( callback_instance, object->userdata, (TP_WAIT *)object, wait_result );
-                    TRACE( "callback %p returned\n", object->u.wait.callback );
-                    break;
-                }
-
-                case TP_OBJECT_TYPE_IO:
-                {
-                    TRACE( "executing I/O callback %p(%p, %p, %#lx, %p, %p)\n",
-                            object->u.io.callback, callback_instance, object->userdata,
-                            completion.cvalue, &completion.iosb, (TP_IO *)object );
-                    object->u.io.callback( callback_instance, object->userdata,
-                            (void *)completion.cvalue, &completion.iosb, (TP_IO *)object );
-                    TRACE( "callback %p returned\n", object->u.io.callback );
-                    break;
-                }
-
-                default:
-                    assert(0);
-                    break;
-            }
-
-            /* Execute finalization callback. */
-            if (object->finalization_callback)
-            {
-                TRACE( "executing finalization callback %p(%p, %p)\n",
-                       object->finalization_callback, callback_instance, object->userdata );
-                object->finalization_callback( callback_instance, object->userdata );
-                TRACE( "callback %p returned\n", object->finalization_callback );
-            }
-
-            /* Execute cleanup tasks. */
-            if (instance.cleanup.critical_section)
-            {
-                RtlLeaveCriticalSection( instance.cleanup.critical_section );
-            }
-            if (instance.cleanup.mutex)
-            {
-                status = NtReleaseMutant( instance.cleanup.mutex, NULL );
-                if (status != STATUS_SUCCESS) goto skip_cleanup;
-            }
-            if (instance.cleanup.semaphore)
-            {
-                status = NtReleaseSemaphore( instance.cleanup.semaphore, instance.cleanup.semaphore_count, NULL );
-                if (status != STATUS_SUCCESS) goto skip_cleanup;
-            }
-            if (instance.cleanup.event)
-            {
-                status = NtSetEvent( instance.cleanup.event, NULL );
-                if (status != STATUS_SUCCESS) goto skip_cleanup;
-            }
-            if (instance.cleanup.library)
-            {
-                LdrUnloadDll( instance.cleanup.library );
-            }
-
-        skip_cleanup:
-            enter_critical_section( &pool->cs );
             assert(pool->num_busy_workers);
             pool->num_busy_workers--;
 
-            /* Simple callbacks are automatically shutdown after execution. */
-            if (object->type == TP_OBJECT_TYPE_SIMPLE)
-            {
-                tp_object_prepare_shutdown( object );
-                object->shutdown = TRUE;
-            }
-
-            object->num_running_callbacks--;
-            if (object_is_finished( object, TRUE ))
-                RtlWakeAllConditionVariable( &object->group_finished_event );
-
-            if (instance.associated)
-            {
-                object->num_associated_callbacks--;
-                if (object_is_finished( object, FALSE ))
-                    RtlWakeAllConditionVariable( &object->finished_event );
-            }
-
             tp_object_release( object );
         }
 
From 1e0919879eabfdf54f085d076199c90c0b6409c4 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 14:32:53 +0100
Subject: [PATCH] ntdll: Re-implement RtlRegisterWait using TpSetWait.

This adds several internal flags to TP_WAIT object to support the
implementation:

* WT_EXECUTEONLYONCE: waits are re-queued unless it is set.

* WT_EXECUTEINWAITTHREAD: call the callback in the wait thread when set.

* WT_EXECUTEINIOTHREAD: call alertable NtWaitForMultipleObjects in wait
  thread when set, as well the callback in the wait thread, as for
  WT_EXECUTEINWAITTHREAD. The worker threads use non-alertable waits
  otherwise.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=47843
---
 dlls/kernel32/tests/thread.c  |   1 -
 dlls/ntdll/tests/threadpool.c |   6 +-
 dlls/ntdll/threadpool.c       | 264 +++++++++++++---------------------
 3 files changed, 100 insertions(+), 171 deletions(-)

diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index 79e2736bd9e..b91dbeca5e9 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -1349,7 +1349,6 @@ static void CALLBACK waitthread_test_function(PVOID p, BOOLEAN TimerOrWaitFired)
 
     SetEvent(param->trigger_event);
     ret = WaitForSingleObject(param->wait_event, 100);
-    todo_wine
     ok(ret == WAIT_TIMEOUT, "wait should have timed out\n");
     SetEvent(param->complete_event);
 }
diff --git a/dlls/ntdll/tests/threadpool.c b/dlls/ntdll/tests/threadpool.c
index b67654ef6a4..3165e137328 100644
--- a/dlls/ntdll/tests/threadpool.c
+++ b/dlls/ntdll/tests/threadpool.c
@@ -323,7 +323,7 @@ static void test_RtlRegisterWait(void)
     result = WaitForSingleObject(semaphores[0], 200);
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
     ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
-    todo_wine ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
+    ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
     result = WaitForSingleObject(semaphores[1], 0);
     ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
     Sleep(50);
@@ -354,7 +354,7 @@ static void test_RtlRegisterWait(void)
     result = WaitForSingleObject(semaphores[0], 200);
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
     ok(info.userdata == 1, "expected info.userdata = 1, got %u\n", info.userdata);
-    todo_wine ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
+    ok(info.threadid == threadid, "unexpected different wait thread id %x\n", info.threadid);
     result = WaitForSingleObject(semaphores[1], 0);
     ok(result == WAIT_TIMEOUT, "WaitForSingleObject returned %u\n", result);
     Sleep(50);
@@ -437,7 +437,6 @@ static void test_RtlRegisterWait(void)
     ok(!status, "RtlDeregisterWaitEx failed with status %x\n", status);
     ok(info.userdata == 0, "expected info.userdata = 0, got %u\n", info.userdata);
     result = WaitForSingleObject(event, 200);
-    todo_wine
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
 
     /* test RtlDeregisterWaitEx after wait expired */
@@ -474,7 +473,6 @@ static void test_RtlRegisterWait(void)
     ok(!status, "RtlDeregisterWaitEx failed with status %x\n", status);
     ok(info.userdata == 0x10000, "expected info.userdata = 0x10000, got %u\n", info.userdata);
     result = WaitForSingleObject(event, 200);
-    todo_wine
     ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
 
     /* test RtlDeregisterWaitEx while callback is running */
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index e9ca32a3be7..331149855ab 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -68,19 +68,6 @@ static RTL_CRITICAL_SECTION_DEBUG critsect_compl_debug =
       0, 0, { (DWORD_PTR)(__FILE__ ": threadpool_compl_cs") }
 };
 
-struct wait_work_item
-{
-    HANDLE Object;
-    HANDLE CancelEvent;
-    WAITORTIMERCALLBACK Callback;
-    PVOID Context;
-    ULONG Milliseconds;
-    ULONG Flags;
-    HANDLE CompletionEvent;
-    LONG DeleteCount;
-    int CallbackInProgress;
-};
-
 struct timer_queue;
 struct queue_timer
 {
@@ -170,6 +157,7 @@ struct threadpool_object
     struct list             pool_entry;
     RTL_CONDITION_VARIABLE  finished_event;
     RTL_CONDITION_VARIABLE  group_finished_event;
+    HANDLE                  completed_event;
     LONG                    num_pending_callbacks;
     LONG                    num_running_callbacks;
     LONG                    num_associated_callbacks;
@@ -206,6 +194,8 @@ struct threadpool_object
             struct list     wait_entry;
             ULONGLONG       timeout;
             HANDLE          handle;
+            DWORD           flags;
+            RTL_WAITORTIMERCALLBACKFUNC rtl_callback;
         } wait;
         struct
         {
@@ -302,6 +292,7 @@ struct waitqueue_bucket
     struct list             reserved;
     struct list             waiting;
     HANDLE                  update_event;
+    BOOL                    alertable;
 };
 
 /* global I/O completion queue object */
@@ -372,7 +363,7 @@ static inline struct threadpool_instance *impl_from_TP_CALLBACK_INSTANCE( TP_CAL
 
 static void CALLBACK threadpool_worker_proc( void *param );
 static void tp_object_submit( struct threadpool_object *object, BOOL signaled );
-static void tp_object_execute( struct threadpool_object *object );
+static void tp_object_execute( struct threadpool_object *object, BOOL wait_thread );
 static void tp_object_prepare_shutdown( struct threadpool_object *object );
 static BOOL tp_object_release( struct threadpool_object *object );
 static struct threadpool *default_threadpool = NULL;
@@ -1266,9 +1257,21 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             if (wait->u.wait.timeout <= now.QuadPart)
             {
                 /* Wait object timed out. */
-                list_remove( &wait->u.wait.wait_entry );
-                list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
-                tp_object_submit( wait, FALSE );
+                if ((wait->u.wait.flags & WT_EXECUTEONLYONCE))
+                {
+                    list_remove( &wait->u.wait.wait_entry );
+                    list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                }
+                if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
+                {
+                    InterlockedIncrement( &wait->refcount );
+                    wait->num_pending_callbacks++;
+                    enter_critical_section( &wait->pool->cs );
+                    tp_object_execute( wait, TRUE );
+                    leave_critical_section( &wait->pool->cs );
+                    tp_object_release( wait );
+                }
+                else tp_object_submit( wait, FALSE );
             }
             else
             {
@@ -1290,7 +1293,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             assert( num_handles == 0 );
             leave_critical_section( &waitqueue.cs );
             timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
-            status = NtWaitForMultipleObjects( 1, &bucket->update_event, TRUE, FALSE, &timeout );
+            status = NtWaitForMultipleObjects( 1, &bucket->update_event, TRUE, bucket->alertable, &timeout );
             enter_critical_section( &waitqueue.cs );
 
             if (status == STATUS_TIMEOUT && !bucket->objcount)
@@ -1300,7 +1303,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
         {
             handles[num_handles] = bucket->update_event;
             leave_critical_section( &waitqueue.cs );
-            status = NtWaitForMultipleObjects( num_handles + 1, handles, TRUE, FALSE, &timeout );
+            status = NtWaitForMultipleObjects( num_handles + 1, handles, TRUE, bucket->alertable, &timeout );
             enter_critical_section( &waitqueue.cs );
 
             if (status >= STATUS_WAIT_0 && status < STATUS_WAIT_0 + num_handles)
@@ -1311,9 +1314,20 @@ static void CALLBACK waitqueue_thread_proc( void *param )
                 {
                     /* Wait object signaled. */
                     assert( wait->u.wait.bucket == bucket );
-                    list_remove( &wait->u.wait.wait_entry );
-                    list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
-                    tp_object_submit( wait, TRUE );
+                    if ((wait->u.wait.flags & WT_EXECUTEONLYONCE))
+                    {
+                        list_remove( &wait->u.wait.wait_entry );
+                        list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                    }
+                    if ((wait->u.wait.flags & (WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD)))
+                    {
+                        wait->u.wait.signaled++;
+                        wait->num_pending_callbacks++;
+                        enter_critical_section( &wait->pool->cs );
+                        tp_object_execute( wait, TRUE );
+                        leave_critical_section( &wait->pool->cs );
+                    }
+                    else tp_object_submit( wait, TRUE );
                 }
                 else
                     WARN("wait object %p triggered while object was destroyed\n", wait);
@@ -1335,7 +1349,7 @@ static void CALLBACK waitqueue_thread_proc( void *param )
             struct waitqueue_bucket *other_bucket;
             LIST_FOR_EACH_ENTRY( other_bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
             {
-                if (other_bucket != bucket && other_bucket->objcount &&
+                if (other_bucket != bucket && other_bucket->objcount && other_bucket->alertable == bucket->alertable &&
                     other_bucket->objcount + bucket->objcount <= MAXIMUM_WAITQUEUE_OBJECTS * 2 / 3)
                 {
                     other_bucket->objcount += bucket->objcount;
@@ -1395,6 +1409,7 @@ static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
     struct waitqueue_bucket *bucket;
     NTSTATUS status;
     HANDLE thread;
+    BOOL alertable = (wait->u.wait.flags & WT_EXECUTEINIOTHREAD) != 0;
     assert( wait->type == TP_OBJECT_TYPE_WAIT );
 
     wait->u.wait.signaled       = 0;
@@ -1408,7 +1423,7 @@ static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
     /* Try to assign to existing bucket if possible. */
     LIST_FOR_EACH_ENTRY( bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
     {
-        if (bucket->objcount < MAXIMUM_WAITQUEUE_OBJECTS)
+        if (bucket->objcount < MAXIMUM_WAITQUEUE_OBJECTS && bucket->alertable == alertable)
         {
             list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
             wait->u.wait.bucket = bucket;
@@ -1428,6 +1443,7 @@ static NTSTATUS tp_waitqueue_lock( struct threadpool_object *wait )
     }
 
     bucket->objcount = 0;
+    bucket->alertable = alertable;
     list_init( &bucket->reserved );
     list_init( &bucket->waiting );
 
@@ -1860,6 +1876,7 @@ static void tp_object_initialize( struct threadpool_object *object, struct threa
     memset( &object->pool_entry, 0, sizeof(object->pool_entry) );
     RtlInitializeConditionVariable( &object->finished_event );
     RtlInitializeConditionVariable( &object->group_finished_event );
+    object->completed_event         = NULL;
     object->num_pending_callbacks   = 0;
     object->num_running_callbacks   = 0;
     object->num_associated_callbacks = 0;
@@ -2077,6 +2094,9 @@ static BOOL tp_object_release( struct threadpool_object *object )
     if (object->race_dll)
         LdrUnloadDll( object->race_dll );
 
+    if (object->completed_event && object->completed_event != INVALID_HANDLE_VALUE)
+        NtSetEvent( object->completed_event, NULL );
+
     RtlFreeHeap( GetProcessHeap(), 0, object );
     return TRUE;
 }
@@ -2101,7 +2121,7 @@ static struct list *threadpool_get_next_item( const struct threadpool *pool )
  * Executes a threadpool object callback, object->pool->cs has to be
  * held.
  */
-static void tp_object_execute( struct threadpool_object *object )
+static void tp_object_execute( struct threadpool_object *object, BOOL wait_thread )
 {
     TP_CALLBACK_INSTANCE *callback_instance;
     struct threadpool_instance instance;
@@ -2129,6 +2149,7 @@ static void tp_object_execute( struct threadpool_object *object )
     object->num_associated_callbacks++;
     object->num_running_callbacks++;
     leave_critical_section( &pool->cs );
+    if (wait_thread) leave_critical_section( &waitqueue.cs );
 
     /* Initialize threadpool instance struct. */
     callback_instance = (TP_CALLBACK_INSTANCE *)&instance;
@@ -2232,6 +2253,7 @@ static void tp_object_execute( struct threadpool_object *object )
     }
 
 skip_cleanup:
+    if (wait_thread) enter_critical_section( &waitqueue.cs );
     enter_critical_section( &pool->cs );
 
     /* Simple callbacks are automatically shutdown after execution. */
@@ -2278,7 +2300,7 @@ static void CALLBACK threadpool_worker_proc( void *param )
             if (object->num_pending_callbacks > 1)
                 tp_object_prio_queue( object );
 
-            tp_object_execute( object );
+            tp_object_execute( object, FALSE );
 
             assert(pool->num_busy_workers);
             pool->num_busy_workers--;
@@ -2418,18 +2440,13 @@ NTSTATUS WINAPI TpAllocTimer( TP_TIMER **out, PTP_TIMER_CALLBACK callback, PVOID
     return STATUS_SUCCESS;
 }
 
-/***********************************************************************
- *           TpAllocWait     (NTDLL.@)
- */
-NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID userdata,
-                             TP_CALLBACK_ENVIRON *environment )
+static NTSTATUS tp_alloc_wait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID userdata,
+                               TP_CALLBACK_ENVIRON *environment, DWORD flags )
 {
     struct threadpool_object *object;
     struct threadpool *pool;
     NTSTATUS status;
 
-    TRACE( "%p %p %p %p\n", out, callback, userdata, environment );
-
     object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
     if (!object)
         return STATUS_NO_MEMORY;
@@ -2443,6 +2460,7 @@ NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID us
 
     object->type = TP_OBJECT_TYPE_WAIT;
     object->u.wait.callback = callback;
+    object->u.wait.flags = flags;
 
     status = tp_waitqueue_lock( object );
     if (status)
@@ -2458,6 +2476,16 @@ NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID us
     return STATUS_SUCCESS;
 }
 
+/***********************************************************************
+ *           TpAllocWait     (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID userdata,
+                             TP_CALLBACK_ENVIRON *environment )
+{
+    TRACE( "%p %p %p %p\n", out, callback, userdata, environment );
+    return tp_alloc_wait( out, callback, userdata, environment, WT_EXECUTEONLYONCE );
+}
+
 /***********************************************************************
  *           TpAllocWork    (NTDLL.@)
  */
@@ -3143,71 +3171,10 @@ NTSTATUS WINAPI TpQueryPoolStackInformation( TP_POOL *pool, TP_POOL_STACK_INFORM
     return STATUS_SUCCESS;
 }
 
-static void delete_wait_work_item(struct wait_work_item *wait_work_item)
+static void CALLBACK rtl_wait_callback( TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WAIT *wait, TP_WAIT_RESULT result )
 {
-    NtClose( wait_work_item->CancelEvent );
-    RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
-}
-
-static DWORD CALLBACK wait_thread_proc(LPVOID Arg)
-{
-    struct wait_work_item *wait_work_item = Arg;
-    NTSTATUS status;
-    BOOLEAN alertable = (wait_work_item->Flags & WT_EXECUTEINIOTHREAD) != 0;
-    HANDLE handles[2] = { wait_work_item->Object, wait_work_item->CancelEvent };
-    LARGE_INTEGER timeout;
-    HANDLE completion_event;
-
-    TRACE("\n");
-
-    while (TRUE)
-    {
-        status = NtWaitForMultipleObjects( 2, handles, TRUE, alertable,
-                                           get_nt_timeout( &timeout, wait_work_item->Milliseconds ) );
-        if (status == STATUS_WAIT_0 || status == STATUS_TIMEOUT)
-        {
-            BOOLEAN TimerOrWaitFired;
-
-            if (status == STATUS_WAIT_0)
-            {
-                TRACE( "object %p signaled, calling callback %p with context %p\n",
-                    wait_work_item->Object, wait_work_item->Callback,
-                    wait_work_item->Context );
-                TimerOrWaitFired = FALSE;
-            }
-            else
-            {
-                TRACE( "wait for object %p timed out, calling callback %p with context %p\n",
-                    wait_work_item->Object, wait_work_item->Callback,
-                    wait_work_item->Context );
-                TimerOrWaitFired = TRUE;
-            }
-            InterlockedExchange( &wait_work_item->CallbackInProgress, TRUE );
-            if (wait_work_item->CompletionEvent)
-            {
-                TRACE( "Work has been canceled.\n" );
-                break;
-            }
-            wait_work_item->Callback( wait_work_item->Context, TimerOrWaitFired );
-            InterlockedExchange( &wait_work_item->CallbackInProgress, FALSE );
-
-            if (wait_work_item->Flags & WT_EXECUTEONLYONCE)
-                break;
-        }
-        else if (status != STATUS_USER_APC)
-            break;
-    }
-
-
-    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
-    {
-        completion_event = wait_work_item->CompletionEvent;
-        delete_wait_work_item( wait_work_item );
-        if (completion_event && completion_event != INVALID_HANDLE_VALUE)
-            NtSetEvent( completion_event, NULL );
-    }
-
-    return 0;
+    struct threadpool_object *object = impl_from_TP_WAIT(wait);
+    object->u.wait.rtl_callback( userdata, result != STATUS_WAIT_0 );
 }
 
 /***********************************************************************
@@ -3235,46 +3202,34 @@ static DWORD CALLBACK wait_thread_proc(LPVOID Arg)
  *|WT_EXECUTELONGFUNCTION - Hints that the execution can take a long time.
  *|WT_TRANSFER_IMPERSONATION - Executes the function with the current access token.
  */
-NTSTATUS WINAPI RtlRegisterWait(PHANDLE NewWaitObject, HANDLE Object,
-                                RTL_WAITORTIMERCALLBACKFUNC Callback,
-                                PVOID Context, ULONG Milliseconds, ULONG Flags)
+NTSTATUS WINAPI RtlRegisterWait( HANDLE *out, HANDLE handle, RTL_WAITORTIMERCALLBACKFUNC callback,
+                                 void *context, ULONG milliseconds, ULONG flags )
 {
-    struct wait_work_item *wait_work_item;
+    struct threadpool_object *object;
+    TP_CALLBACK_ENVIRON environment;
+    LARGE_INTEGER timeout;
     NTSTATUS status;
+    TP_WAIT *wait;
 
-    TRACE( "(%p, %p, %p, %p, %d, 0x%x)\n", NewWaitObject, Object, Callback, Context, Milliseconds, Flags );
-
-    wait_work_item = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*wait_work_item) );
-    if (!wait_work_item)
-        return STATUS_NO_MEMORY;
+    TRACE( "out %p, handle %p, callback %p, context %p, milliseconds %u, flags %x\n",
+            out, handle, callback, context, milliseconds, flags );
 
-    wait_work_item->Object = Object;
-    wait_work_item->Callback = Callback;
-    wait_work_item->Context = Context;
-    wait_work_item->Milliseconds = Milliseconds;
-    wait_work_item->Flags = Flags;
-    wait_work_item->CallbackInProgress = FALSE;
-    wait_work_item->DeleteCount = 0;
-    wait_work_item->CompletionEvent = NULL;
+    memset( &environment, 0, sizeof(environment) );
+    environment.Version = 1;
+    environment.u.s.LongFunction = (flags & WT_EXECUTELONGFUNCTION) != 0;
+    environment.u.s.Persistent   = (flags & WT_EXECUTEINPERSISTENTTHREAD) != 0;
 
-    status = NtCreateEvent( &wait_work_item->CancelEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
-    if (status != STATUS_SUCCESS)
-    {
-        RtlFreeHeap( GetProcessHeap(), 0, wait_work_item );
+    flags &= (WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD | WT_EXECUTEINIOTHREAD);
+    if ((status = tp_alloc_wait( &wait, rtl_wait_callback, context, &environment, flags )))
         return status;
-    }
 
-    Flags = Flags & (WT_EXECUTEINIOTHREAD | WT_EXECUTEINPERSISTENTTHREAD |
-                     WT_EXECUTELONGFUNCTION | WT_TRANSFER_IMPERSONATION);
-    status = RtlQueueWorkItem( wait_thread_proc, wait_work_item, Flags );
-    if (status != STATUS_SUCCESS)
-    {
-        delete_wait_work_item( wait_work_item );
-        return status;
-    }
+    object = impl_from_TP_WAIT(wait);
+    object->u.wait.rtl_callback = callback;
 
-    *NewWaitObject = wait_work_item;
-    return status;
+    TpSetWait( (TP_WAIT *)object, handle, get_nt_timeout( &timeout, milliseconds ) );
+
+    *out = object;
+    return STATUS_SUCCESS;
 }
 
 /***********************************************************************
@@ -3290,54 +3245,31 @@ NTSTATUS WINAPI RtlRegisterWait(PHANDLE NewWaitObject, HANDLE Object,
  *  Success: STATUS_SUCCESS.
  *  Failure: Any NTSTATUS code.
  */
-NTSTATUS WINAPI RtlDeregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent)
+NTSTATUS WINAPI RtlDeregisterWaitEx( HANDLE handle, HANDLE event )
 {
-    struct wait_work_item *wait_work_item = WaitHandle;
+    struct threadpool_object *object = handle;
     NTSTATUS status;
-    HANDLE LocalEvent = NULL;
-    int CallbackInProgress;
 
-    TRACE( "(%p %p)\n", WaitHandle, CompletionEvent );
+    TRACE( "handle %p, event %p\n", handle, event );
 
-    if (WaitHandle == NULL)
-        return STATUS_INVALID_HANDLE;
+    if (!object) return STATUS_INVALID_HANDLE;
 
-    InterlockedExchangePointer( &wait_work_item->CompletionEvent, INVALID_HANDLE_VALUE );
-    CallbackInProgress = wait_work_item->CallbackInProgress;
-    TRACE( "callback in progress %u\n", CallbackInProgress );
-    if (CompletionEvent == INVALID_HANDLE_VALUE || !CallbackInProgress)
-    {
-        status = NtCreateEvent( &LocalEvent, EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE );
-        if (status != STATUS_SUCCESS)
-            return status;
-        InterlockedExchangePointer( &wait_work_item->CompletionEvent, LocalEvent );
-    }
-    else if (CompletionEvent != NULL)
-    {
-        InterlockedExchangePointer( &wait_work_item->CompletionEvent, CompletionEvent );
-    }
+    TpSetWait( (TP_WAIT *)object, NULL, NULL );
 
-    NtSetEvent( wait_work_item->CancelEvent, NULL );
-
-    if (InterlockedIncrement( &wait_work_item->DeleteCount ) == 2 )
-    {
-        status = STATUS_SUCCESS;
-        delete_wait_work_item( wait_work_item );
-    }
-    else if (LocalEvent)
-    {
-        TRACE( "Waiting for completion event\n" );
-        NtWaitForSingleObject( LocalEvent, FALSE, NULL );
-        status = STATUS_SUCCESS;
-    }
+    if (event == INVALID_HANDLE_VALUE) TpWaitForWait( (TP_WAIT *)object, TRUE );
     else
     {
-        status = STATUS_PENDING;
+        assert( object->completed_event == NULL );
+        object->completed_event = event;
     }
 
-    if (LocalEvent)
-        NtClose( LocalEvent );
+    enter_critical_section( &object->pool->cs );
+    if (object->num_pending_callbacks + object->num_running_callbacks
+        + object->num_associated_callbacks) status = STATUS_PENDING;
+    else status = STATUS_SUCCESS;
+    leave_critical_section( &object->pool->cs );
 
+    TpReleaseWait( (TP_WAIT *)object );
     return status;
 }
 
From 37b42fdc5b13cfbe8f73d815107b36932cfc8d06 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 30 Nov 2020 19:49:51 +0100
Subject: [PATCH] kernel32: Write the wait handle before executing the
 callback.

Otherwise we may execute the callback before the value is actually
returned from RegisterWaitForSingleObject.

Gears Tactics shares a pointer to the returned handle with its callbacks
and calls UnregisterWait from there. This creates a race condition that
sometimes causes a double free.

Note that calling RtlDeregisterWait from the wait callback crashes on
Windows whereas it is fine to call UnregisterWait. Maybe it should be
implemented separately, but it should not matter too much.

The test also shows that UnregisterWait does not return ERROR_IO_PENDING
when called from the callback itself, although we currently do.
---
 dlls/kernel32/sync.c         |  3 +-
 dlls/kernel32/tests/thread.c | 61 ++++++++++++++++++++++++++++++++++++
 dlls/ntdll/threadpool.c      |  3 ++
 3 files changed, 66 insertions(+), 1 deletion(-)

diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index b3a59a4df97..33d5aad90aa 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -117,7 +117,8 @@ DWORD WINAPI DECLSPEC_HOTPATCH GetTickCount(void)
 BOOL WINAPI RegisterWaitForSingleObject( HANDLE *wait, HANDLE object, WAITORTIMERCALLBACK callback,
                                          void *context, ULONG timeout, ULONG flags )
 {
-    return (*wait = RegisterWaitForSingleObjectEx( object, callback, context, timeout, flags)) != NULL;
+    if (!set_ntstatus( RtlRegisterWait( wait, object, callback, context, timeout, flags ))) return FALSE;
+    return TRUE;
 }
 
 /***********************************************************************
diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index b91dbeca5e9..62677052ff6 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -1328,6 +1328,15 @@ static void CALLBACK signaled_function(PVOID p, BOOLEAN TimerOrWaitFired)
     ok(!TimerOrWaitFired, "wait shouldn't have timed out\n");
 }
 
+static void CALLBACK wait_complete_function(PVOID p, BOOLEAN TimerOrWaitFired)
+{
+    HANDLE event = p;
+    DWORD res;
+    ok(!TimerOrWaitFired, "wait shouldn't have timed out\n");
+    res = WaitForSingleObject(event, INFINITE);
+    ok(res == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", res);
+}
+
 static void CALLBACK timeout_function(PVOID p, BOOLEAN TimerOrWaitFired)
 {
     HANDLE event = p;
@@ -1353,6 +1362,23 @@ static void CALLBACK waitthread_test_function(PVOID p, BOOLEAN TimerOrWaitFired)
     SetEvent(param->complete_event);
 }
 
+struct unregister_params
+{
+    HANDLE wait_handle;
+    HANDLE complete_event;
+};
+
+static void CALLBACK unregister_function(PVOID p, BOOLEAN TimerOrWaitFired)
+{
+    struct unregister_params *param = p;
+    HANDLE wait_handle = param->wait_handle;
+    BOOL ret;
+    ok(wait_handle != INVALID_HANDLE_VALUE, "invalid wait handle\n");
+    ret = pUnregisterWait(param->wait_handle);
+    todo_wine ok(ret, "UnregisterWait failed with error %d\n", GetLastError());
+    SetEvent(param->complete_event);
+}
+
 static void test_RegisterWaitForSingleObject(void)
 {
     BOOL ret;
@@ -1361,6 +1387,8 @@ static void test_RegisterWaitForSingleObject(void)
     HANDLE complete_event;
     HANDLE waitthread_trigger_event, waitthread_wait_event;
     struct waitthread_test_param param;
+    struct unregister_params unregister_param;
+    DWORD i;
 
     if (!pRegisterWaitForSingleObject || !pUnregisterWait)
     {
@@ -1393,8 +1421,26 @@ static void test_RegisterWaitForSingleObject(void)
     ret = pUnregisterWait(wait_handle);
     ok(ret, "UnregisterWait failed with error %d\n", GetLastError());
 
+    /* test unregister while running */
+
+    SetEvent(handle);
+    ret = pRegisterWaitForSingleObject(&wait_handle, handle, wait_complete_function, complete_event, INFINITE, WT_EXECUTEONLYONCE);
+    ok(ret, "RegisterWaitForSingleObject failed with error %d\n", GetLastError());
+
+    /* give worker thread chance to start */
+    Sleep(50);
+    ret = pUnregisterWait(wait_handle);
+    ok(!ret, "UnregisterWait succeeded\n");
+    ok(GetLastError() == ERROR_IO_PENDING, "UnregisterWait failed with error %d\n", GetLastError());
+
+    /* give worker thread chance to complete */
+    SetEvent(complete_event);
+    Sleep(50);
+
     /* test timeout case */
 
+    ResetEvent(handle);
+
     ret = pRegisterWaitForSingleObject(&wait_handle, handle, timeout_function, complete_event, 0, WT_EXECUTEONLYONCE);
     ok(ret, "RegisterWaitForSingleObject failed with error %d\n", GetLastError());
 
@@ -1424,6 +1470,21 @@ static void test_RegisterWaitForSingleObject(void)
     ret = pUnregisterWait(wait_handle);
     ok(ret, "UnregisterWait failed with error %d\n", GetLastError());
 
+    /* the callback execution should be sequentially consistent with the wait handle return,
+       even if the event is already set */
+
+    for (i = 0; i < 100; ++i)
+    {
+        SetEvent(handle);
+        unregister_param.complete_event = complete_event;
+        unregister_param.wait_handle = INVALID_HANDLE_VALUE;
+
+        ret = pRegisterWaitForSingleObject(&unregister_param.wait_handle, handle, unregister_function, &unregister_param, INFINITE, WT_EXECUTEONLYONCE | WT_EXECUTEINWAITTHREAD);
+        ok(ret, "RegisterWaitForSingleObject failed with error %d\n", GetLastError());
+
+        WaitForSingleObject(complete_event, INFINITE);
+    }
+
     /* test multiple waits with WT_EXECUTEINWAITTHREAD.
      * Windows puts multiple waits on the same wait thread, and using WT_EXECUTEINWAITTHREAD causes the callbacks to run serially.
      */
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 331149855ab..bdc1ebddd7d 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -3226,9 +3226,12 @@ NTSTATUS WINAPI RtlRegisterWait( HANDLE *out, HANDLE handle, RTL_WAITORTIMERCALL
     object = impl_from_TP_WAIT(wait);
     object->u.wait.rtl_callback = callback;
 
+    enter_critical_section( &waitqueue.cs );
     TpSetWait( (TP_WAIT *)object, handle, get_nt_timeout( &timeout, milliseconds ) );
 
     *out = object;
+    leave_critical_section( &waitqueue.cs );
+
     return STATUS_SUCCESS;
 }
 
From 7dea6e020b043226f2a8fa85986a88e899725fad Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Dec 2020 11:06:11 +0100
Subject: [PATCH] winhttp: Move connect end checks out of the loop.

This is only done when InitializeSecurityContextW returns SEC_E_OK,
which will break out of the loop, and the checks forcefully break out
of the loop if any failed.
---
 dlls/winhttp/net.c | 66 ++++++++++++++++++++++------------------------
 1 file changed, 32 insertions(+), 34 deletions(-)

diff --git a/dlls/winhttp/net.c b/dlls/winhttp/net.c
index 0cc2bb2bef7..46dc6bd21f0 100644
--- a/dlls/winhttp/net.c
+++ b/dlls/winhttp/net.c
@@ -341,53 +341,51 @@ DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD secur
         status = InitializeSecurityContextW(cred_handle, &ctx, hostname,  isc_req_flags, 0, 0, &in_desc,
                 0, NULL, &out_desc, &attrs, NULL);
         TRACE("InitializeSecurityContext ret %08x\n", status);
+        if(status == SEC_E_OK && in_bufs[1].BufferType == SECBUFFER_EXTRA)
+            FIXME("SECBUFFER_EXTRA not supported\n");
+    }
 
-        if(status == SEC_E_OK) {
-            if(in_bufs[1].BufferType == SECBUFFER_EXTRA)
-                FIXME("SECBUFFER_EXTRA not supported\n");
-
-            status = QueryContextAttributesW(&ctx, SECPKG_ATTR_STREAM_SIZES, &conn->ssl_sizes);
-            if(status != SEC_E_OK) {
-                WARN("Could not get sizes\n");
-                break;
-            }
+    heap_free(read_buf);
 
-            status = QueryContextAttributesW(&ctx, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (void*)&cert);
-            if(status == SEC_E_OK) {
-                res = netconn_verify_cert(cert, hostname, security_flags, check_revocation);
-                CertFreeCertificateContext(cert);
-                if(res != ERROR_SUCCESS) {
-                    WARN("cert verify failed: %u\n", res);
-                    break;
-                }
-            }else {
-                WARN("Could not get cert\n");
-                break;
-            }
+    if(status != SEC_E_OK)
+        goto failed;
 
-            conn->ssl_buf = heap_alloc(conn->ssl_sizes.cbHeader + conn->ssl_sizes.cbMaximumMessage + conn->ssl_sizes.cbTrailer);
-            if(!conn->ssl_buf) {
-                res = ERROR_OUTOFMEMORY;
-                break;
-            }
-        }
+    status = QueryContextAttributesW(&ctx, SECPKG_ATTR_STREAM_SIZES, &conn->ssl_sizes);
+    if(status != SEC_E_OK) {
+        WARN("Could not get sizes\n");
+        goto failed;
     }
 
-    heap_free(read_buf);
+    status = QueryContextAttributesW(&ctx, SECPKG_ATTR_REMOTE_CERT_CONTEXT, (void*)&cert);
+    if(status != SEC_E_OK) {
+        WARN("Could not get cert\n");
+        goto failed;
+    }
 
-    if(status != SEC_E_OK || res != ERROR_SUCCESS) {
-        WARN("Failed to initialize security context: %08x\n", status);
-        heap_free(conn->ssl_buf);
-        conn->ssl_buf = NULL;
-        DeleteSecurityContext(&ctx);
-        return ERROR_WINHTTP_SECURE_CHANNEL_ERROR;
+    res = netconn_verify_cert(cert, hostname, security_flags, check_revocation);
+    CertFreeCertificateContext(cert);
+    if(res != ERROR_SUCCESS) {
+        WARN("cert verify failed: %u\n", res);
+        goto failed;
     }
 
+    conn->ssl_buf = heap_alloc(conn->ssl_sizes.cbHeader + conn->ssl_sizes.cbMaximumMessage + conn->ssl_sizes.cbTrailer);
+    if(!conn->ssl_buf) {
+        res = ERROR_OUTOFMEMORY;
+        goto failed;
+    }
 
     TRACE("established SSL connection\n");
     conn->secure = TRUE;
     conn->ssl_ctx = ctx;
     return ERROR_SUCCESS;
+
+failed:
+    WARN("Failed to initialize security context: %08x\n", status);
+    heap_free(conn->ssl_buf);
+    conn->ssl_buf = NULL;
+    DeleteSecurityContext(&ctx);
+    return ERROR_WINHTTP_SECURE_CHANNEL_ERROR;
 }
 
 static DWORD send_ssl_chunk( struct netconn *conn, const void *msg, size_t size )
From 24a210159124e8818291370e9843562e6a47fe1c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Dec 2020 11:14:07 +0100
Subject: [PATCH] winhttp: Introduce new netconn_negotiate helper.

---
 dlls/winhttp/net.c | 34 ++++++++++++++++++++++------------
 1 file changed, 22 insertions(+), 12 deletions(-)

diff --git a/dlls/winhttp/net.c b/dlls/winhttp/net.c
index 46dc6bd21f0..2ba9b2dc65a 100644
--- a/dlls/winhttp/net.c
+++ b/dlls/winhttp/net.c
@@ -259,27 +259,22 @@ void netconn_close( struct netconn *conn )
     heap_free(conn);
 }
 
-DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD security_flags, CredHandle *cred_handle,
-                              BOOL check_revocation )
+static DWORD netconn_negotiate(struct netconn *conn, CredHandle *cred_handle, CtxtHandle *ctx_handle, WCHAR *hostname,
+                               DWORD isc_req_flags, SecBufferDesc *init_desc, CtxtHandle *new_ctx_handle)
 {
     SecBuffer out_buf = {0, SECBUFFER_TOKEN, NULL}, in_bufs[2] = {{0, SECBUFFER_TOKEN}, {0, SECBUFFER_EMPTY}};
     SecBufferDesc out_desc = {SECBUFFER_VERSION, 1, &out_buf}, in_desc = {SECBUFFER_VERSION, 2, in_bufs};
     BYTE *read_buf;
     SIZE_T read_buf_size = 2048;
     ULONG attrs = 0;
-    CtxtHandle ctx;
     SSIZE_T size;
-    const CERT_CONTEXT *cert;
     SECURITY_STATUS status;
-    DWORD res = ERROR_SUCCESS;
-
-    const DWORD isc_req_flags = ISC_REQ_ALLOCATE_MEMORY|ISC_REQ_USE_SESSION_KEY|ISC_REQ_CONFIDENTIALITY
-        |ISC_REQ_SEQUENCE_DETECT|ISC_REQ_REPLAY_DETECT|ISC_REQ_MANUAL_CRED_VALIDATION;
 
     if (!(read_buf = heap_alloc( read_buf_size ))) return ERROR_OUTOFMEMORY;
 
-    status = InitializeSecurityContextW(cred_handle, NULL, hostname, isc_req_flags, 0, 0, NULL, 0,
-            &ctx, &out_desc, &attrs, NULL);
+    status = InitializeSecurityContextW(cred_handle, ctx_handle, hostname, isc_req_flags, 0, 0, init_desc,
+            0, new_ctx_handle, &out_desc, &attrs, NULL);
+    if (!ctx_handle) ctx_handle = new_ctx_handle;
 
     assert(status != SEC_E_OK);
 
@@ -292,7 +287,7 @@ DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD secur
             size = sock_send(conn->socket, out_buf.pvBuffer, out_buf.cbBuffer, 0);
             if(size != out_buf.cbBuffer) {
                 ERR("send failed\n");
-                res = ERROR_WINHTTP_SECURE_CHANNEL_ERROR;
+                status = ERROR_WINHTTP_SECURE_CHANNEL_ERROR;
                 break;
             }
 
@@ -338,7 +333,7 @@ DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD secur
 
         in_bufs[0].cbBuffer += size;
         in_bufs[0].pvBuffer = read_buf;
-        status = InitializeSecurityContextW(cred_handle, &ctx, hostname,  isc_req_flags, 0, 0, &in_desc,
+        status = InitializeSecurityContextW(cred_handle, ctx_handle, hostname, isc_req_flags, 0, 0, &in_desc,
                 0, NULL, &out_desc, &attrs, NULL);
         TRACE("InitializeSecurityContext ret %08x\n", status);
         if(status == SEC_E_OK && in_bufs[1].BufferType == SECBUFFER_EXTRA)
@@ -347,6 +342,21 @@ DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD secur
 
     heap_free(read_buf);
 
+    return status;
+}
+
+DWORD netconn_secure_connect( struct netconn *conn, WCHAR *hostname, DWORD security_flags, CredHandle *cred_handle,
+                              BOOL check_revocation )
+{
+    CtxtHandle ctx;
+    const CERT_CONTEXT *cert;
+    SECURITY_STATUS status;
+    DWORD res = ERROR_SUCCESS;
+
+    const DWORD isc_req_flags = ISC_REQ_ALLOCATE_MEMORY|ISC_REQ_USE_SESSION_KEY|ISC_REQ_CONFIDENTIALITY
+        |ISC_REQ_SEQUENCE_DETECT|ISC_REQ_REPLAY_DETECT|ISC_REQ_MANUAL_CRED_VALIDATION;
+
+    status = netconn_negotiate(conn, cred_handle, NULL, hostname, isc_req_flags, NULL, &ctx);
     if(status != SEC_E_OK)
         goto failed;
 
From da118414609cf44c57a1d8cbe208d49aab11d9df Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Dec 2020 11:52:27 +0100
Subject: [PATCH] winhttp: Handle SEC_I_RENEGOTIATE after DecryptMessage.

By performing renegotiation as we should, instead of incorrectly
returning ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED.

MSDN says we should pass returned SECBUFFER_EXTRA as SECBUFFER_TOKEN,
so we also do that, although it's usually empty.
---
 dlls/winhttp/net.c | 15 +++++++++++++--
 1 file changed, 13 insertions(+), 2 deletions(-)

diff --git a/dlls/winhttp/net.c b/dlls/winhttp/net.c
index 2ba9b2dc65a..ba262a83391 100644
--- a/dlls/winhttp/net.c
+++ b/dlls/winhttp/net.c
@@ -454,8 +454,10 @@ DWORD netconn_send( struct netconn *conn, const void *msg, size_t len, int *sent
 
 static DWORD read_ssl_chunk( struct netconn *conn, void *buf, SIZE_T buf_size, SIZE_T *ret_size, BOOL *eof )
 {
+    const DWORD isc_req_flags = ISC_REQ_ALLOCATE_MEMORY|ISC_REQ_USE_SESSION_KEY|ISC_REQ_CONFIDENTIALITY
+        |ISC_REQ_SEQUENCE_DETECT|ISC_REQ_REPLAY_DETECT|ISC_REQ_USE_SUPPLIED_CREDS;
     const SIZE_T ssl_buf_size = conn->ssl_sizes.cbHeader+conn->ssl_sizes.cbMaximumMessage+conn->ssl_sizes.cbTrailer;
-    SecBuffer bufs[4];
+    SecBuffer bufs[4], tmp;
     SecBufferDesc buf_desc = {SECBUFFER_VERSION, ARRAY_SIZE(bufs), bufs};
     SSIZE_T size, buf_len;
     unsigned int i;
@@ -496,7 +498,16 @@ static DWORD read_ssl_chunk( struct netconn *conn, void *buf, SIZE_T buf_size, S
 
         case SEC_I_RENEGOTIATE:
             TRACE("renegotiate\n");
-            return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED;
+            memset(&tmp, 0, sizeof(tmp));
+            for(i = 0; i < ARRAY_SIZE(bufs); i++) {
+                if(bufs[i].BufferType == SECBUFFER_EXTRA) tmp = bufs[i];
+            }
+            memset(bufs, 0, sizeof(bufs));
+            bufs[0] = tmp;
+            bufs[0].BufferType = SECBUFFER_TOKEN;
+            res = netconn_negotiate(conn, NULL, &conn->ssl_ctx, conn->host->hostname, isc_req_flags, &buf_desc, NULL);
+            if (res != SEC_E_OK) return res;
+            break;
 
         case SEC_I_CONTEXT_EXPIRED:
             TRACE("context expired\n");
From 2397c333b565199fd8fab24c35b67248246f9875 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Dec 2020 11:26:56 +0100
Subject: [PATCH] secur32: Perform TLS handshake even if input is empty.

Instead of immediately returning even if we don't know how much.

This may be the case if we received SEC_I_RENEGOTIATE status, and in any
case the handshake will tell us if more data is needed.
---
 dlls/secur32/schannel.c | 4 +++-
 1 file changed, 3 insertions(+), 1 deletion(-)

diff --git a/dlls/secur32/schannel.c b/dlls/secur32/schannel.c
index e76a3e46c34..918f4eff8d2 100644
--- a/dlls/secur32/schannel.c
+++ b/dlls/secur32/schannel.c
@@ -881,7 +881,7 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
             ptr += record_size;
         }
 
-        if (!expected_size)
+        if (!expected_size && record_size)
         {
             TRACE("Expected at least %lu bytes, but buffer only contains %u bytes.\n",
                     max(6, record_size), buffer->cbBuffer);
@@ -912,6 +912,8 @@ static SECURITY_STATUS SEC_ENTRY schan_InitializeSecurityContextW(
     {
         SecBuffer *buffer = &out_buffers->desc->pBuffers[0];
         buffer->cbBuffer = 0;
+        /* Nothing to read or to send, but we got SEC_I_CONTINUE_NEEDED, it means missing input */
+        if (!expected_size && ret == SEC_I_CONTINUE_NEEDED) ret = SEC_E_INCOMPLETE_MESSAGE;
     }
 
     if(ctx->transport.in.offset && ctx->transport.in.offset != pInput->pBuffers[0].cbBuffer) {
From b8c99b0041abdd1cb1841ce79cebdb5e172d7e93 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 3 Dec 2020 10:53:35 +0100
Subject: [PATCH] secur32: Return STREAM_HEADER/TRAILER buffers on
 SEC_I_RENEGOTIATE.

And don't print an error anymore.
---
 dlls/secur32/schannel.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/dlls/secur32/schannel.c b/dlls/secur32/schannel.c
index 918f4eff8d2..f7ced5437bb 100644
--- a/dlls/secur32/schannel.c
+++ b/dlls/secur32/schannel.c
@@ -1331,6 +1331,7 @@ static void schan_decrypt_fill_buffer(PSecBufferDesc message, ULONG buffer_type,
 static SECURITY_STATUS SEC_ENTRY schan_DecryptMessage(PCtxtHandle context_handle,
         PSecBufferDesc message, ULONG message_seq_no, PULONG quality)
 {
+    SECURITY_STATUS status = SEC_E_OK;
     struct schan_context *ctx;
     SecBuffer *buffer;
     SIZE_T data_size;
@@ -1380,10 +1381,16 @@ static SECURITY_STATUS SEC_ENTRY schan_DecryptMessage(PCtxtHandle context_handle
     while (received < data_size)
     {
         SIZE_T length = data_size - received;
-        SECURITY_STATUS status = schan_imp_recv(ctx->session, data + received, &length);
+        status = schan_imp_recv(ctx->session, data + received, &length);
+
+        if (status == SEC_I_RENEGOTIATE)
+            break;
 
         if (status == SEC_I_CONTINUE_NEEDED)
+        {
+            status = SEC_E_OK;
             break;
+        }
 
         if (status != SEC_E_OK)
         {
@@ -1416,7 +1423,7 @@ static SECURITY_STATUS SEC_ENTRY schan_DecryptMessage(PCtxtHandle context_handle
     buffer->BufferType = SECBUFFER_STREAM_HEADER;
     buffer->cbBuffer = 5;
 
-    return SEC_E_OK;
+    return status;
 }
 
 static SECURITY_STATUS SEC_ENTRY schan_DeleteSecurityContext(PCtxtHandle context_handle)
